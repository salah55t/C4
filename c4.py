# Ù…Ù„Ù c4_complete_v28_fixed.py - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© ÙˆØ§Ù„Ù…ØµØ­Ø­Ø© V28# ØªÙ… Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡ ÙˆØªØµØ­ÙŠØ­Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© Geminiimport timeimport osimport jsonimport loggingimport requestsimport numpy as npimport pandas as pdimport psycopg2import pickleimport redisimport reimport gcimport randomfrom decimal import Decimal, ROUND_DOWNfrom urllib.parse import urlparsefrom psycopg2 import sql, OperationalError, InterfaceErrorfrom psycopg2.extras import RealDictCursorfrom binance.client import Clientfrom binance.exceptions import BinanceAPIExceptionfrom flask import Flask, jsonify, render_template_stringfrom flask_cors import CORSfrom threading import Thread, Lockfrom datetime import datetime, timezonefrom decouple import configfrom typing import List, Dict, Optional, Any, Set, Tuplefrom sklearn.preprocessing import StandardScalerfrom collections import dequeimport warnings# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¬Ø§Ù‡Ù„ ÙˆØ§Ù„Ù„ÙˆØ¬Ø± ---warnings.simplefilter(action='ignore', category=FutureWarning)warnings.simplefilter(action='ignore', category=UserWarning)logging.basicConfig(    level=logging.INFO,    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',    handlers=[        logging.FileHandler('crypto_bot_v28_complete_logs.log', encoding='utf-8'),        logging.StreamHandler()    ])logger = logging.getLogger('CryptoBotV28_Complete')# --- ØªØ­Ù…ÙŠÙ„ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© ---try:    API_KEY: str = config('BINANCE_API_KEY')    API_SECRET: str = config('BINANCE_API_SECRET')    DB_URL: str = config('DATABASE_URL')    REDIS_URL: str = config('REDIS_URL', default='redis://localhost:6379/0')except Exception as e:    logger.critical(f"âŒ ÙØ´Ù„ Ø­Ø§Ø³Ù… ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©: {e}")    exit(1)# --- Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© ÙˆØ¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª ---is_trading_enabled: bool = Falsetrading_status_lock = Lock()force_momentum_strategy: bool = Falseforce_momentum_lock = Lock()RISK_PER_TRADE_PERCENT: float = 1.0BASE_ML_MODEL_NAME: str = 'LightGBM_Scalping_V8_With_Momentum'MODEL_FOLDER: str = 'V8'SIGNAL_GENERATION_TIMEFRAME: str = '15m'TIMEFRAMES_FOR_TREND_LIGHTS: List[str] = ['15m', '1h', '4h']SIGNAL_GENERATION_LOOKBACK_DAYS: int = 30REDIS_PRICES_HASH_NAME: str = "crypto_bot_current_prices_v8"TRADING_FEE_PERCENT: float = 0.1STATS_TRADE_SIZE_USDT: float = 10.0BTC_SYMBOL: str = 'BTCUSDT'SYMBOL_PROCESSING_BATCH_SIZE: int = 50MAX_OPEN_TRADES: int = 4BUY_CONFIDENCE_THRESHOLD = 0.80# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© ---ADX_PERIOD: int = 14RSI_PERIOD: int = 14ATR_PERIOD: int = 14EMA_FAST_PERIOD: int = 50EMA_SLOW_PERIOD: int = 200REL_VOL_PERIOD: int = 30MOMENTUM_PERIOD: int = 12EMA_SLOPE_PERIOD: int = 5# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ---USE_TRAILING_STOP_LOSS: bool = TrueTRAILING_ACTIVATION_PROFIT_PERCENT: float = 1.0TRAILING_DISTANCE_PERCENT: float = 0.8USE_PEAK_FILTER: bool = TruePEAK_CHECK_PERIOD: int = 50PULLBACK_THRESHOLD_PCT: float = 0.988BREAKOUT_ALLOWANCE_PCT: float = 1.003DYNAMIC_FILTER_ANALYSIS_INTERVAL: int = 300ORDER_BOOK_DEPTH_LIMIT: int = 100ORDER_BOOK_WALL_MULTIPLIER: float = 10.0ORDER_BOOK_ANALYSIS_RANGE_PCT: float = 0.02# --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø© ÙˆØ§Ù„ÙƒØ§Ø´ ---conn: Optional[psycopg2.extensions.connection] = Noneclient: Optional[Client] = Noneredis_client: Optional[redis.Redis] = Noneml_models_cache: Dict[str, Any] = {}exchange_info_map: Dict[str, Any] = {}validated_symbols_to_scan: List[str] = []open_signals_cache: Dict[str, Dict] = {}signal_cache_lock = Lock()notifications_cache = deque(maxlen=50)notifications_lock = Lock()rejection_logs_cache = deque(maxlen=100)rejection_logs_lock = Lock()current_market_state: Dict[str, Any] = {"overall_regime": "INITIALIZING", "trend_details_by_tf": {}, "last_updated": None}market_state_lock = Lock()dynamic_filter_profile_cache: Dict[str, Any] = {}last_dynamic_filter_analysis_time: float = 0dynamic_filter_lock = Lock()last_market_state_check = 0# --- Ù‚Ø§Ù…ÙˆØ³ Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ø±ÙØ¶ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ---REJECTION_REASONS_AR = {    "Filters Not Loaded": "Ø§Ù„ÙÙ„Ø§ØªØ± ØºÙŠØ± Ù…Ø­Ù…Ù„Ø©",    "Low Volatility": "ØªÙ‚Ù„Ø¨ Ù…Ù†Ø®ÙØ¶ Ø¬Ø¯Ø§Ù‹",    "BTC Correlation": "Ø§Ø±ØªØ¨Ø§Ø· Ø¶Ø¹ÙŠÙ Ø¨Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†",    "RRR Filter": "Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©/Ø§Ù„Ø¹Ø§Ø¦Ø¯ ØºÙŠØ± ÙƒØ§ÙÙŠØ©",    "Reversal Volume Filter": "ÙÙˆÙ„ÙŠÙˆÙ… Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³ Ø¶Ø¹ÙŠÙ",    "Momentum/Strength Filter": "ÙÙ„ØªØ± Ø§Ù„Ø²Ø®Ù… ÙˆØ§Ù„Ù‚ÙˆØ©",    "Peak/Pullback Filter": "ÙÙ„ØªØ± Ø§Ù„Ù‚Ù…Ø©/Ø§Ù„ØªØµØ­ÙŠØ­",    "Invalid ATR for TP/SL": "ATR ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù",    "Reversal Signal Rejected by ML Model": "Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ Ø±ÙØ¶ Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³",    "Invalid Position Size": "Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© ØºÙŠØ± ØµØ§Ù„Ø­ (Ø§Ù„ÙˆÙ‚Ù ØªØ­Øª Ø§Ù„Ø¯Ø®ÙˆÙ„)",    "Lot Size Adjustment Failed": "ÙØ´Ù„ Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„Ø¹Ù‚Ø¯ (LOT_SIZE)",    "Min Notional Filter": "Ù‚ÙŠÙ…Ø© Ø§Ù„ØµÙÙ‚Ø© Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰",    "Insufficient Balance": "Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ",    "Order Book Fetch Failed": "ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª",    "Order Book Imbalance": "Ø§Ø®ØªÙ„Ø§Ù„ ØªÙˆØ§Ø²Ù† Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª (Ø¶ØºØ· Ø¨ÙŠØ¹)",    "Large Sell Wall Detected": "ØªÙ… ÙƒØ´Ù Ø¬Ø¯Ø§Ø± Ø¨ÙŠØ¹ Ø¶Ø®Ù…",}# --- Ø¯ÙˆØ§Ù„ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø®Ø¯Ù…Ø§Øª ---def init_db(retries: int = 5, delay: int = 5) -> None:    """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©."""    global conn    logger.info("[DB] ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")    db_url_to_use = DB_URL    if 'postgres' in db_url_to_use and 'sslmode' not in db_url_to_use:        separator = '&' if '?' in db_url_to_use else '?'        db_url_to_use += f"{separator}sslmode=require"        for attempt in range(retries):        try:            conn = psycopg2.connect(db_url_to_use, connect_timeout=15, cursor_factory=RealDictCursor)            conn.autocommit = False                        with conn.cursor() as cur:                cur.execute("""                    CREATE TABLE IF NOT EXISTS signals (                        id SERIAL PRIMARY KEY, symbol TEXT NOT NULL, entry_price DOUBLE PRECISION NOT NULL,                        target_price DOUBLE PRECISION NOT NULL, stop_loss DOUBLE PRECISION NOT NULL,                        status TEXT DEFAULT 'open', closing_price DOUBLE PRECISION, closed_at TIMESTAMP,                        profit_percentage DOUBLE PRECISION, strategy_name TEXT, signal_details JSONB,                        current_peak_price DOUBLE PRECISION, is_real_trade BOOLEAN DEFAULT FALSE,                        quantity DOUBLE PRECISION, order_id TEXT                    );                """)                cur.execute("CREATE INDEX IF NOT EXISTS idx_signals_status ON signals (status);")                cur.execute("""                    CREATE TABLE IF NOT EXISTS notifications (                        id SERIAL PRIMARY KEY, timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                        type TEXT NOT NULL, message TEXT NOT NULL, is_read BOOLEAN DEFAULT FALSE                    );                """)            conn.commit()            logger.info("âœ… [DB] Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø®Ø·Ø· Ø¨Ù†Ø¬Ø§Ø­.")            return        except Exception as e:            logger.error(f"âŒ [DB] Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙ‡ÙŠØ¦Ø© (Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1}/{retries}): {e}")            if conn: conn.rollback()            if attempt < retries - 1: time.sleep(delay)            else: logger.critical("âŒ [DB] ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.")def check_db_connection() -> bool:    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©."""    global conn    if conn is None or conn.closed != 0:        logger.warning("[DB] Ø§Ù„Ø§ØªØµØ§Ù„ Ù…ØºÙ„Ù‚ØŒ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„...")        init_db()    try:        if conn and conn.closed == 0:            with conn.cursor() as cur: cur.execute("SELECT 1;")            return True        return False    except (OperationalError, InterfaceError) as e:        logger.error(f"âŒ [DB] ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø§ØªØµØ§Ù„: {e}. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„...")        try:            init_db()            return conn is not None and conn.closed == 0        except Exception as retry_e:            logger.error(f"âŒ [DB] ÙØ´Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„: {retry_e}")            return Falsedef log_and_notify(level: str, message: str, notification_type: str):    """ØªØ³Ø¬ÙŠÙ„ Ø±Ø³Ø§Ù„Ø© ÙˆØ¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¥Ù„Ù‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª."""    log_methods = {'info': logger.info, 'warning': logger.warning, 'error': logger.error, 'critical': logger.critical}    log_methods.get(level.lower(), logger.info)(message)    if not check_db_connection() or not conn: return    try:        new_notification = {"timestamp": datetime.now(timezone.utc).isoformat(), "type": notification_type, "message": message}        with notifications_lock: notifications_cache.appendleft(new_notification)        with conn.cursor() as cur: cur.execute("INSERT INTO notifications (type, message) VALUES (%s, %s);", (notification_type, message))        conn.commit()    except Exception as e:        logger.error(f"âŒ [Notify DB] ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±: {e}")        if conn: conn.rollback()def log_rejection(symbol: str, reason_key: str, details: Optional[Dict] = None):    """ØªØ³Ø¬ÙŠÙ„ Ø³Ø¨Ø¨ Ø±ÙØ¶ ØµÙÙ‚Ø© Ù…Ø¹ÙŠÙ†Ø©."""    reason_ar = REJECTION_REASONS_AR.get(reason_key, reason_key)    log_message = f"ğŸš« [REJECTED] {symbol} | Reason: {reason_key} | Details: {details or {}}"    logger.info(log_message)    with rejection_logs_lock:        rejection_logs_cache.appendleft({            "timestamp": datetime.now(timezone.utc).isoformat(),            "symbol": symbol,            "reason": reason_ar,            "details": details or {}        })def init_redis() -> None:    """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø®Ø§Ø¯Ù… Redis."""    global redis_client    logger.info("[Redis] ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Redis...")    try:        redis_client = redis.from_url(REDIS_URL, decode_responses=True)        redis_client.ping()        logger.info("âœ… [Redis] ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­ Ø¨Ø®Ø§Ø¯Ù… Redis.")    except redis.exceptions.ConnectionError as e:        logger.critical(f"âŒ [Redis] ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Redis: {e}")        exit(1)def get_exchange_info_map() -> None:    """Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ÙˆÙ‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ù…Ù† Ù…Ù†ØµØ© Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³."""    global exchange_info_map    if not client: return    logger.info("â„¹ï¸ [Exchange Info] Ø¬Ù„Ø¨ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ù…Ù† Ø§Ù„Ù…Ù†ØµØ©...")    try:        info = client.get_exchange_info()        exchange_info_map = {s['symbol']: s for s in info['symbols']}        logger.info(f"âœ… [Exchange Info] ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ù„Ù€ {len(exchange_info_map)} Ø¹Ù…Ù„Ø©.")    except Exception as e:        logger.error(f"âŒ [Exchange Info] Ù„Ù… ÙŠØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù†ØµØ©: {e}")def get_validated_symbols(filename: str = 'crypto_list.txt') -> List[str]:    """Ù‚Ø±Ø§Ø¡Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ù…Ù† Ù…Ù„Ù ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØªÙ‡Ø§ Ù„Ù„ØªØ¯Ø§ÙˆÙ„."""    if not client: return []    try:        script_dir = os.path.dirname(os.path.abspath(__file__))        file_path = os.path.join(script_dir, filename)        if not os.path.exists(file_path):            logger.warning(f"âš ï¸ Ù…Ù„Ù Ø§Ù„Ø¹Ù…Ù„Ø§Øª '{filename}' ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‚Ø§Ø¦Ù…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©.")            # ÙŠÙ…ÙƒÙ†Ùƒ ÙˆØ¶Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª            raw_symbols = {'BTC', 'ETH', 'BNB', 'SOL', 'XRP'}        else:            with open(file_path, 'r', encoding='utf-8') as f:                raw_symbols = {line.strip().upper() for line in f if line.strip() and not line.startswith('#')}                formatted = {f"{s}USDT" if not s.endswith('USDT') else s for s in raw_symbols}                if not exchange_info_map: get_exchange_info_map()        active = {s for s, info in exchange_info_map.items() if info.get('quoteAsset') == 'USDT' and info.get('status') == 'TRADING'}        validated = sorted(list(formatted.intersection(active)))        logger.info(f"âœ… [Validation] Ø³ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨ÙˆØª Ø¨Ù…Ø±Ø§Ù‚Ø¨Ø© {len(validated)} Ø¹Ù…Ù„Ø©.")        return validated    except Exception as e:        logger.error(f"âŒ [Validation] Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¹Ù…Ù„Ø§Øª: {e}", exc_info=True)        return []def fetch_historical_data(symbol: str, interval: str, days: int) -> Optional[pd.DataFrame]:    """Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ© Ù„Ø¹Ù…Ù„Ø© Ù…Ø¹ÙŠÙ†Ø©."""    if not client: return None    try:        # Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©        minutes_in_interval = int(re.sub('[a-zA-Z]', '', interval))        if 'h' in interval: minutes_in_interval *= 60        if 'd' in interval: minutes_in_interval *= 1440        limit = int((days * 24 * 60) / minutes_in_interval)                klines = client.get_historical_klines(symbol, interval, limit=min(limit, 1000))        if not klines: return None                df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'quote_volume', 'trades', 'taker_buy_base', 'taker_buy_quote', 'ignore'])        df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]        for col in ['open', 'high', 'low', 'close', 'volume']:            df[col] = pd.to_numeric(df[col], errors='coerce')                df = df.astype({'open': np.float32, 'high': np.float32, 'low': np.float32, 'close': np.float32, 'volume': np.float32})        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)        df.set_index('timestamp', inplace=True)        return df.dropna()    except BinanceAPIException as e:        logger.error(f"âŒ [Data] Ø®Ø·Ø£ Ù…Ù† Binance API Ù„Ù€ {symbol}: {e}")        if e.code == -1003:            logger.critical("ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù€ IP! Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù…Ø¯Ø© 60 Ø«Ø§Ù†ÙŠØ©.")            time.sleep(60)        return None    except Exception as e:        logger.error(f"âŒ [Data] Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ© Ù„Ù€ {symbol}: {e}")        return Nonedef analyze_order_book(symbol: str, entry_price: float) -> Optional[Dict[str, Any]]:    """ØªØ­Ù„ÙŠÙ„ Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª (Order Book) Ù„ØªÙ‚ÙŠÙŠÙ… Ø¶ØºØ· Ø§Ù„Ø¨ÙŠØ¹ ÙˆØ§Ù„Ø´Ø±Ø§Ø¡."""    if not client: return None    try:        order_book = client.get_order_book(symbol=symbol, limit=ORDER_BOOK_DEPTH_LIMIT)                bids = pd.DataFrame(order_book['bids'], columns=['price', 'qty'], dtype=float)        asks = pd.DataFrame(order_book['asks'], columns=['price', 'qty'], dtype=float)        price_range = entry_price * ORDER_BOOK_ANALYSIS_RANGE_PCT        relevant_bids_vol = bids[bids['price'] >= entry_price - price_range]['qty'].sum()        relevant_asks_vol = asks[asks['price'] <= entry_price + price_range]['qty'].sum()        bid_ask_ratio = relevant_bids_vol / relevant_asks_vol if relevant_asks_vol > 0 else float('inf')        # ØªØµØ­ÙŠØ­: ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ù…ÙƒØ±Ø± Ù‡Ù†Ø§        avg_ask_qty = asks['qty'].mean()        sell_wall_threshold = avg_ask_qty * ORDER_BOOK_WALL_MULTIPLIER        nearby_asks = asks[asks['price'].between(entry_price, entry_price * 1.05)]        large_sell_walls = nearby_asks[nearby_asks['qty'] > sell_wall_threshold]        analysis_result = {            "bid_ask_ratio": bid_ask_ratio,            "has_large_sell_wall": not large_sell_walls.empty,            "wall_details": large_sell_walls.to_dict('records') if not large_sell_walls.empty else []        }        logger.info(f"ğŸ“– [{symbol}] ØªØ­Ù„ÙŠÙ„ Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª: Ø§Ù„Ù†Ø³Ø¨Ø©={bid_ask_ratio:.2f}, ÙˆØ¬ÙˆØ¯ Ø¬Ø¯Ø§Ø± Ø¨ÙŠØ¹={analysis_result['has_large_sell_wall']}")        return analysis_result    except Exception as e:        logger.error(f"âŒ [{symbol}] ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø£Ùˆ ØªØ­Ù„ÙŠÙ„ Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª: {e}")        log_rejection(symbol, "Order Book Fetch Failed", {"error": str(e)})        return Nonedef calculate_features(df: pd.DataFrame, btc_df: Optional[pd.DataFrame]) -> pd.DataFrame:    """Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© ÙˆØ§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ."""    df_calc = df.copy()        # ATR    high_low = df_calc['high'] - df_calc['low']    high_close = (df_calc['high'] - df_calc['close'].shift()).abs()    low_close = (df_calc['low'] - df_calc['close'].shift()).abs()    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)    df_calc['atr'] = tr.ewm(span=ATR_PERIOD, adjust=False).mean()        # ADX    up_move = df_calc['high'].diff()    down_move = -df_calc['low'].diff()    plus_dm = pd.Series(np.where((up_move > down_move) & (up_move > 0), up_move, 0.0), index=df_calc.index)    minus_dm = pd.Series(np.where((down_move > up_move) & (down_move > 0), down_move, 0.0), index=df_calc.index)    plus_di = 100 * plus_dm.ewm(span=ADX_PERIOD, adjust=False).mean() / df_calc['atr'].replace(0, 1e-9)    minus_di = 100 * minus_dm.ewm(span=ADX_PERIOD, adjust=False).mean() / df_calc['atr'].replace(0, 1e-9)    dx = 100 * (abs(plus_di - minus_di) / (plus_di + minus_di).replace(0, 1e-9))    df_calc['adx'] = dx.ewm(span=ADX_PERIOD, adjust=False).mean()        # RSI    delta = df_calc['close'].diff()    gain = delta.clip(lower=0).ewm(com=RSI_PERIOD - 1, adjust=False).mean()    loss = -delta.clip(upper=0).ewm(com=RSI_PERIOD - 1, adjust=False).mean()    df_calc['rsi'] = 100 - (100 / (1 + (gain / loss.replace(0, 1e-9))))        # Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„ÙÙˆÙ„ÙŠÙˆÙ… ÙˆØ§Ù„Ø³Ø¹Ø±    df_calc['relative_volume'] = df_calc['volume'] / (df_calc['volume'].rolling(window=REL_VOL_PERIOD, min_periods=1).mean() + 1e-9)    df_calc['price_vs_ema50'] = (df_calc['close'] / df_calc['close'].ewm(span=EMA_FAST_PERIOD, adjust=False).mean()) - 1    df_calc['price_vs_ema200'] = (df_calc['close'] / df_calc['close'].ewm(span=EMA_SLOW_PERIOD, adjust=False).mean()) - 1        # Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†    if btc_df is not None and not btc_df.empty:        merged_df = pd.merge(df_calc, btc_df[['btc_returns']], left_index=True, right_index=True, how='left').fillna(0)        df_calc['btc_correlation'] = df_calc['close'].pct_change().rolling(window=30).corr(merged_df['btc_returns'])    else:        df_calc['btc_correlation'] = 0.0            # ROC Ùˆ Ù…ÙŠÙ„ EMA    df_calc[f'roc_{MOMENTUM_PERIOD}'] = (df_calc['close'] / df_calc['close'].shift(MOMENTUM_PERIOD) - 1) * 100    ema_slope = df_calc['close'].ewm(span=EMA_SLOPE_PERIOD, adjust=False).mean()    df_calc[f'ema_slope_{EMA_SLOPE_PERIOD}'] = (ema_slope - ema_slope.shift(1)) / ema_slope.shift(1).replace(0, 1e-9) * 100        return df_calc.astype('float32', errors='ignore')def get_session_state() -> Tuple[List[str], str, str]:    """ØªØ­Ø¯ÙŠØ¯ Ø¬Ù„Ø³Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø© ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ø³ÙŠÙˆÙ„Ø©."""    sessions = {"London": (8, 17), "New York": (13, 22), "Tokyo": (0, 9)}    active_sessions = []    now_utc = datetime.now(timezone.utc)    current_hour = now_utc.hour    if now_utc.weekday() >= 5: # Ø§Ù„Ø³Ø¨Øª ÙˆØ§Ù„Ø£Ø­Ø¯        return [], "WEEKEND", "Ø³ÙŠÙˆÙ„Ø© Ù…Ù†Ø®ÙØ¶Ø© Ø¬Ø¯Ø§ (Ø¹Ø·Ù„Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹)"    for session, (start, end) in sessions.items():        if start <= current_hour < end:            active_sessions.append(session)    if "London" in active_sessions and "New York" in active_sessions:        return active_sessions, "HIGH_LIQUIDITY", "Ø³ÙŠÙˆÙ„Ø© Ø¹Ø§Ù„ÙŠØ© (ØªØ¯Ø§Ø®Ù„ Ù„Ù†Ø¯Ù†/Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ)"    elif len(active_sessions) >= 1:        return active_sessions, "NORMAL_LIQUIDITY", f"Ø³ÙŠÙˆÙ„Ø© Ø¹Ø§Ø¯ÙŠØ© ({', '.join(active_sessions)})"    else:        return [], "LOW_LIQUIDITY", "Ø³ÙŠÙˆÙ„Ø© Ù…Ù†Ø®ÙØ¶Ø© (Ø®Ø§Ø±Ø¬ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø°Ø±ÙˆØ©)"def get_btc_data_for_bot() -> Optional[pd.DataFrame]:    """Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ† Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª."""    btc_data = fetch_historical_data(BTC_SYMBOL, SIGNAL_GENERATION_TIMEFRAME, SIGNAL_GENERATION_LOOKBACK_DAYS)    if btc_data is not None:        btc_data['btc_returns'] = btc_data['close'].pct_change()    return btc_datadef load_open_signals_to_cache():    """ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ø´ Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„."""    if not check_db_connection() or not conn: return    try:        with conn.cursor() as cur:            cur.execute("SELECT * FROM signals WHERE status IN ('open', 'updated');")            open_signals = cur.fetchall()            with signal_cache_lock:                open_signals_cache.clear()                # ØªØµØ­ÙŠØ­: ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø­Ù„Ù‚Ø© Ù„ØªØ¹Ø¨Ø¦Ø© Ø§Ù„ÙƒØ§Ø´ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­                for signal in open_signals:                     open_signals_cache[signal['symbol']] = dict(signal)            logger.info(f"âœ… [Loading] ØªÙ… ØªØ­Ù…ÙŠÙ„ {len(open_signals)} ØµÙÙ‚Ø© Ù…ÙØªÙˆØ­Ø©.")    except Exception as e:        logger.error(f"âŒ [Loading] ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©: {e}")def load_notifications_to_cache():    """ØªØ­Ù…ÙŠÙ„ Ø¢Ø®Ø± Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ø´."""    if not check_db_connection() or not conn: return    try:        with conn.cursor() as cur:            cur.execute("SELECT * FROM notifications ORDER BY timestamp DESC LIMIT 50;")            recent = cur.fetchall()            with notifications_lock:                notifications_cache.clear()                for n in reversed(recent):                    n['timestamp'] = n['timestamp'].isoformat()                    notifications_cache.appendleft(dict(n))            logger.info(f"âœ… [Loading] ØªÙ… ØªØ­Ù…ÙŠÙ„ {len(notifications_cache)} Ø¥Ø´Ø¹Ø§Ø±.")    except Exception as e:        logger.error(f"âŒ [Loading] ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª: {e}")# ---------------------- Ø£Ù†Ø¸Ù…Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ----------------------class MarketConditionsAnalyzer:    """ÙØ¦Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ø¹Ø§Ù…Ø© (ØªÙ‚Ù„Ø¨ØŒ ÙÙˆÙ„ÙŠÙˆÙ…ØŒ Ø§Ø±ØªØ¨Ø§Ø·)."""    def __init__(self):        self.conditions_cache = {}        self.last_analysis = 0        def analyze_conditions(self) -> Dict[str, Any]:        """Ø¥Ø¬Ø±Ø§Ø¡ ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ Ù„Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚."""        current_time = time.time()        if current_time - self.last_analysis < 300: # ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚            return self.conditions_cache                try:            conditions = {                'volatility_regime': self._get_volatility_regime(),                'volume_regime': self._get_volume_regime(),                'correlation_regime': self._get_correlation_regime(),                'session_type': self._get_session_type()            }                        self.conditions_cache = conditions            self.last_analysis = current_time            return conditions                    except Exception as e:            logger.error(f"âŒ [Market Conditions] Ø®Ø·Ø£: {e}")            return self._get_default_conditions()        def _get_volatility_regime(self) -> str:        """ØªØ­Ø¯ÙŠØ¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚Ù„Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ATR Ù„Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†."""        try:            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 7)            if btc_data is None: return "normal"                        returns = btc_data['close'].pct_change()            # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ù„Ø¨ Ø§Ù„Ø³Ù†ÙˆÙŠ Ø¨Ø§Ù„Ø³Ø§Ø¹Ø©            volatility = returns.rolling(24).std().iloc[-1] * np.sqrt(24 * 365) * 100                        if volatility < 20: return "low"            elif volatility < 60: return "normal"            else: return "high"        except: return "normal"        def _get_volume_regime(self) -> str:        """ØªØ­Ø¯ÙŠØ¯ Ù†Ø¸Ø§Ù… Ø§Ù„ÙÙˆÙ„ÙŠÙˆÙ…."""        try:            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 7)            if btc_data is None: return "normal"                        volume = btc_data['volume']            # ØªØµØ­ÙŠØ­: ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ù…ÙƒØ³ÙˆØ± Ù‡Ù†Ø§            avg_volume = volume.rolling(24).mean().iloc[-1]            current_volume = volume.iloc[-1]            ratio = current_volume / avg_volume if avg_volume > 0 else 1                        if ratio < 0.7: return "low"            elif ratio < 1.5: return "normal"            else: return "high"        except: return "normal"        def _get_correlation_regime(self) -> str:        """ØªØ­Ø¯ÙŠØ¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙˆØ§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†."""        try:            major_coins = ['ETHUSDT', 'ADAUSDT', 'SOLUSDT', 'DOTUSDT']            correlations = []            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 2)            if btc_data is None: return "normal"                        btc_returns = btc_data['close'].pct_change().dropna()            for coin in major_coins:                data = fetch_historical_data(coin, '1h', 2)                if data is not None:                    coin_returns = data['close'].pct_change().dropna()                    # Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø£Ø·ÙˆØ§Ù„                    common_index = btc_returns.index.intersection(coin_returns.index)                    if len(common_index) > 10:                        corr = btc_returns.loc[common_index].corr(coin_returns.loc[common_index])                        correlations.append(abs(corr))            avg_correlation = np.mean(correlations) if correlations else 0.5            if avg_correlation < 0.3: return "low"            elif avg_correlation < 0.7: return "normal"            else: return "high"        except: return "normal"    def _get_session_type(self) -> str:        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ù…Ù† Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø©."""        _, liquidity_state, _ = get_session_state()        return liquidity_state        def _get_default_conditions(self) -> Dict[str, Any]:        """Ø¥Ø±Ø¬Ø§Ø¹ Ù‚ÙŠÙ… Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ÙÙŠ Ø­Ø§Ù„ ÙØ´Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„."""        return {'volatility_regime': 'normal', 'volume_regime': 'normal', 'correlation_regime': 'normal', 'session_type': 'NORMAL_LIQUIDITY'}class EnhancedFilterSystem:    """Ù†Ø¸Ø§Ù… Ù„ØªÙˆÙ„ÙŠØ¯ ÙÙ„Ø§ØªØ± ØªØ¯Ø§ÙˆÙ„ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚."""    def __init__(self):        self.analyzer = MarketConditionsAnalyzer()        def generate_filters(self) -> Dict[str, Any]:        """ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ù ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙ."""        conditions = self.analyzer.analyze_conditions()        base_profile = {            "adx": 25.0, "rel_vol": 0.4, "rsi_range": (52, 88), "roc": 0.05,            "slope": 0.01, "min_rrr": 1.4, "min_volatility_pct": 0.35,            "min_btc_correlation": 0.4, "min_bid_ask_ratio": 1.15        }                # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø¸Ø±ÙˆÙ        if conditions['volatility_regime'] == "low":            base_profile['min_volatility_pct'] *= 0.7            base_profile['min_rrr'] *= 1.2        elif conditions['volatility_regime'] == "high":            base_profile['min_volatility_pct'] *= 1.3            base_profile['min_rrr'] *= 0.8                if conditions['volume_regime'] == "low":            base_profile['rel_vol'] *= 0.5        elif conditions['volume_regime'] == "high":            base_profile['rel_vol'] *= 1.2                if conditions['correlation_regime'] == "high":            base_profile['min_btc_correlation'] = max(0.7, base_profile['min_btc_correlation'])        elif conditions['correlation_regime'] == "low":            base_profile['min_btc_correlation'] = max(0.2, base_profile['min_btc_correlation'])                return {            "name": f"ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙØ© - {conditions['volatility_regime']}",            "description": f"Ù†Ø¸Ø§Ù… Ù…ØªÙƒÙŠÙ: {conditions['volatility_regime']}/{conditions['volume_regime']}",            "strategy": "MOMENTUM",            "filters": base_profile,            "conditions": conditions        }enhanced_filter_system = EnhancedFilterSystem()# ---------------------- Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªØ¯Ø§ÙˆÙ„ ÙˆØ§Ù„ÙÙ„Ø§ØªØ± ----------------------class EnhancedTradingStrategy:    """ÙØ¦Ø© Ù„ØªØºÙ„ÙŠÙ Ù…Ù†Ø·Ù‚ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ."""    def __init__(self, symbol: str):        self.symbol = symbol        model_bundle = self._load_ml_model(symbol)        self.ml_model, self.scaler, self.feature_names = (model_bundle.get('model'), model_bundle.get('scaler'), model_bundle.get('feature_names')) if model_bundle else (None, None, None)    def _load_ml_model(self, symbol: str) -> Optional[Dict[str, Any]]:        """ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ Ù…Ù† Ù…Ù„Ù."""        model_name = f"{BASE_ML_MODEL_NAME}_{symbol}"        if model_name in ml_models_cache:            return ml_models_cache[model_name]                script_dir = os.path.dirname(os.path.abspath(__file__))        model_dir_path = os.path.join(script_dir, MODEL_FOLDER)        model_path = os.path.join(model_dir_path, f"{model_name}.pkl")                if not os.path.exists(model_path):            return None                try:            with open(model_path, 'rb') as f:                model_bundle = pickle.load(f)            if 'model' in model_bundle and 'scaler' in model_bundle and 'feature_names' in model_bundle:                ml_models_cache[model_name] = model_bundle                return model_bundle            return None        except Exception as e:            logger.error(f"âŒ [ML Model] Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ù„Ù€ {symbol}: {e}")            return None    def get_features(self, df_15m: pd.DataFrame, df_4h: pd.DataFrame, btc_df: pd.DataFrame) -> Optional[pd.DataFrame]:        """ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ù…ÙŠØ²Ø§Øª Ù„Ù„Ù†Ù…ÙˆØ°Ø¬."""        if self.feature_names is None: return None        try:            df_featured = calculate_features(df_15m, btc_df)            df_4h_features = calculate_features(df_4h, None)            df_4h_features = df_4h_features.rename(columns=lambda c: f"{c}_4h", inplace=False)            required_4h_cols = ['rsi_4h', 'price_vs_ema50_4h']            df_featured = df_featured.join(df_4h_features[required_4h_cols], how='outer')            df_featured.fillna(method='ffill', inplace=True)            for col in self.feature_names:                if col not in df_featured.columns:                    df_featured[col] = 0.0            df_featured.replace([np.inf, -np.inf], np.nan, inplace=True)            return df_featured.dropna(subset=self.feature_names)        except Exception as e:            logger.error(f"âŒ [{self.symbol}] ÙØ´Ù„ Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ù…ÙŠØ²Ø§Øª: {e}", exc_info=True)            return None    def generate_buy_signal(self, df_features: pd.DataFrame) -> Optional[Dict[str, Any]]:        """ØªÙˆÙ„ÙŠØ¯ Ø¥Ø´Ø§Ø±Ø© Ø´Ø±Ø§Ø¡ Ù…Ù† Ø§Ù„Ù†Ù…ÙˆØ°Ø¬."""        if not all([self.ml_model, self.scaler, self.feature_names]) or df_features.empty:            return None        try:            last_row_ordered_df = df_features.iloc[[-1]][self.feature_names]            features_scaled_np = self.scaler.transform(last_row_ordered_df)            features_scaled_df = pd.DataFrame(features_scaled_np, columns=self.feature_names)            prediction = self.ml_model.predict(features_scaled_df)[0]            if prediction != 1:                return None                        prediction_proba = self.ml_model.predict_proba(features_scaled_df)            confidence = float(np.max(prediction_proba[0]))            logger.debug(f"â„¹ï¸ [{self.symbol}] ØªÙ†Ø¨Ø£ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¨Ù€ 'Ø´Ø±Ø§Ø¡' Ø¨Ø«Ù‚Ø© {confidence:.2%}.")            return {'prediction': int(prediction), 'confidence': confidence}        except Exception as e:            logger.warning(f"âš ï¸ [{self.symbol}] Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: {e}")            return Nonedef passes_filters(symbol: str, last_features: pd.Series, profile: Dict[str, Any], entry_price: float, tp_sl_data: Dict, df_15m: pd.DataFrame) -> bool:    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¥Ø´Ø§Ø±Ø© ØªÙ…Ø± Ø¹Ø¨Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©."""    filters = profile.get("filters", {})    if not filters:        log_rejection(symbol, "Filters Not Loaded", {"profile": profile.get('name')})        return False        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙ‚Ù„Ø¨    volatility = (last_features.get('atr', 0) / entry_price * 100) if entry_price > 0 else 0    if volatility < filters.get('min_volatility_pct', 0.0):        log_rejection(symbol, "Low Volatility", {"volatility": f"{volatility:.2f}%", "min": f"{filters.get('min_volatility_pct', 0.0):.2f}%"})        return False    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†    correlation = last_features.get('btc_correlation', 0)    if correlation < filters.get('min_btc_correlation', -1.0):        log_rejection(symbol, "BTC Correlation", {"corr": f"{correlation:.2f}", "min": f"{filters.get('min_btc_correlation', -1.0)}"})        return False    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø© Ù„Ù„Ø¹Ø§Ø¦Ø¯    risk = entry_price - float(tp_sl_data['stop_loss'])    reward = float(tp_sl_data['target_price']) - entry_price    if risk <= 0 or reward <= 0 or (reward / risk) < filters.get('min_rrr', 0.0):        log_rejection(symbol, "RRR Filter", {"rrr": f"{(reward/risk):.2f}" if risk > 0 else "N/A", "min": f"{filters.get('min_rrr', 0.0):.2f}"})        return False    # ÙÙ„Ø§ØªØ± Ø§Ù„Ø²Ø®Ù…    adx = last_features.get('adx', 0)    rel_vol = last_features.get('relative_volume', 0)    rsi = last_features.get('rsi', 0)    roc = last_features.get(f'roc_{MOMENTUM_PERIOD}', 0)    slope = last_features.get(f'ema_slope_{EMA_SLOPE_PERIOD}', 0)    rsi_min, rsi_max = filters.get('rsi_range', (0, 100))    if not (adx >= filters.get('adx', 0) and             rel_vol >= filters.get('rel_vol', 0) and             rsi_min <= rsi < rsi_max and            roc > filters.get('roc', -100) and            slope > filters.get('slope', -100)):        log_rejection(symbol, "Momentum/Strength Filter", {            "ADX": f"{adx:.2f}", "Volume": f"{rel_vol:.2f}", "RSI": f"{rsi:.2f}",            "ROC": f"{roc:.2f}", "Slope": f"{slope:.6f}"        })        return False        # ÙÙ„ØªØ± Ø§Ù„Ù‚Ù…Ø©/Ø§Ù„ØªØµØ­ÙŠØ­    if USE_PEAK_FILTER:        with market_state_lock:            market_regime = current_market_state.get("overall_regime", "RANGING")        if df_15m is not None and len(df_15m) >= PEAK_CHECK_PERIOD:            recent_candles = df_15m.iloc[-PEAK_CHECK_PERIOD:-1]            if not recent_candles.empty:                highest_high = recent_candles['high'].max()                is_strong_uptrend = (market_regime == "STRONG_UPTREND")                # Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ø®ØªØ±Ø§Ù‚ Ø¨Ø³ÙŠØ· ÙÙŠ Ø§Ù„ØªØ±Ù†Ø¯ Ø§Ù„Ù‚ÙˆÙŠØŒ Ø£Ùˆ Ø§Ù†ØªØ¸Ø§Ø± ØªØµØ­ÙŠØ­ ÙÙŠ Ø§Ù„ØªØ±Ù†Ø¯ Ø§Ù„Ø¹Ø§Ø¯ÙŠ                price_limit = highest_high * (BREAKOUT_ALLOWANCE_PCT if is_strong_uptrend else PULLBACK_THRESHOLD_PCT)                if not (entry_price <= price_limit):                    log_rejection(symbol, "Peak/Pullback Filter", {"entry": f"{entry_price:.4f}", "limit": f"{price_limit:.4f}"})                    return False    return Truedef passes_order_book_check(symbol: str, order_book_analysis: Dict, profile: Dict) -> bool:    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙÙ„Ø§ØªØ± Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª."""    filters = profile.get("filters", {})    min_ratio = filters.get('min_bid_ask_ratio', 1.0)        if order_book_analysis.get('has_large_sell_wall', True):        log_rejection(symbol, "Large Sell Wall Detected", {"details": order_book_analysis.get('wall_details')})        return False            bid_ask_ratio = order_book_analysis.get('bid_ask_ratio', 0)    if bid_ask_ratio < min_ratio:        log_rejection(symbol, "Order Book Imbalance", {"ratio": f"{bid_ask_ratio:.2f}", "min_required": min_ratio})        return False            return Truedef calculate_tp_sl(symbol: str, entry_price: float, last_atr: float) -> Optional[Dict[str, Any]]:    """Ø­Ø³Ø§Ø¨ ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© ÙˆØ¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ATR."""    if last_atr <= 0:        log_rejection(symbol, "Invalid ATR for TP/SL", {"atr": last_atr})        return None    # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¶Ø§Ø¹ÙØ§Øª ATR Ø§ÙØªØ±Ø§Ø¶ÙŠØ©    tp = entry_price + (last_atr * 2.2)    sl = entry_price - (last_atr * 1.5)    return {'target_price': tp, 'stop_loss': sl, 'source': 'ATR_Fallback'}# ---------------------- Ø¯ÙˆØ§Ù„ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØµÙÙ‚Ø§Øª ----------------------def adjust_quantity_to_lot_size(symbol: str, quantity: float) -> Optional[Decimal]:    """ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙƒÙ…ÙŠØ© Ù„ØªØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ù‚Ø§Ø¹Ø¯Ø© LOT_SIZE Ù„Ù„Ù…Ù†ØµØ©."""    try:        symbol_info = exchange_info_map.get(symbol)        if not symbol_info: return None        for f in symbol_info['filters']:            if f['filterType'] == 'LOT_SIZE':                step_size = Decimal(f['stepSize'])                return (Decimal(str(quantity)) // step_size) * step_size        return Decimal(str(quantity))    except Exception as e:        logger.error(f"[{symbol}] Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙƒÙ…ÙŠØ© Ø­Ø³Ø¨ LOT_SIZE: {e}")        return Nonedef calculate_position_size(symbol: str, entry_price: float, stop_loss_price: float) -> Optional[Decimal]:    """Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±."""    if not client: return None    try:        balance_response = client.get_asset_balance(asset='USDT')        available_balance = Decimal(balance_response['free'])        risk_amount_usdt = available_balance * (Decimal(str(RISK_PER_TRADE_PERCENT)) / Decimal('100'))                risk_per_coin = Decimal(str(entry_price)) - Decimal(str(stop_loss_price))        if risk_per_coin <= 0:            log_rejection(symbol, "Invalid Position Size", {"detail": "ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ØªØ­Øª Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„."})            return None                    initial_quantity = risk_amount_usdt / risk_per_coin        adjusted_quantity = adjust_quantity_to_lot_size(symbol, float(initial_quantity))        if adjusted_quantity is None or adjusted_quantity <= 0:            log_rejection(symbol, "Lot Size Adjustment Failed", {"quantity": f"{adjusted_quantity}"})            return None        notional_value = adjusted_quantity * Decimal(str(entry_price))        symbol_info = exchange_info_map.get(symbol)        if symbol_info:            for f in symbol_info['filters']:                if f['filterType'] in ('MIN_NOTIONAL', 'NOTIONAL'):                    min_notional = Decimal(f.get('minNotional', f.get('notional', '0')))                    if notional_value < min_notional:                        log_rejection(symbol, "Min Notional Filter", {"value": f"{notional_value:.2f}", "required": f"{min_notional}"})                        return None                if notional_value > available_balance:            log_rejection(symbol, "Insufficient Balance", {"required": f"{notional_value:.2f}", "available": f"{available_balance:.2f}"})            return None        logger.info(f"âœ… [{symbol}] ØªÙ… Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø©: {adjusted_quantity} | Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©: ${risk_amount_usdt:.2f}")        return adjusted_quantity    except Exception as e:        logger.error(f"âŒ [{symbol}] Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø©: {e}", exc_info=True)        return Nonedef place_order(symbol: str, side: str, quantity: Decimal, order_type: str = Client.ORDER_TYPE_MARKET) -> Optional[Dict]:    """ØªÙ†ÙÙŠØ° Ø£Ù…Ø± ØªØ¯Ø§ÙˆÙ„ Ø­Ù‚ÙŠÙ‚ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØµØ©."""    if not client: return None    logger.info(f"â¡ï¸ [{symbol}] Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ†ÙÙŠØ° Ø£Ù…Ø± {side} Ø­Ù‚ÙŠÙ‚ÙŠ Ù„ÙƒÙ…ÙŠØ© {quantity}.")    try:        order = client.create_order(symbol=symbol, side=side, type=order_type, quantity=float(quantity))        logger.info(f"âœ… [{symbol}] ØªÙ… ØªÙ†ÙÙŠØ° Ø£Ù…Ø± {side} Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ù†Ø¬Ø§Ø­! Order ID: {order['orderId']}")        log_and_notify('info', f"TRADE REAL: Placed {side} order for {quantity} {symbol}.", "REAL_TRADE")        return order    except Exception as e:        logger.error(f"âŒ [{symbol}] Ø®Ø·Ø£ Ù…Ù† Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³ Ø¹Ù†Ø¯ ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ù…Ø±: {e}")        log_and_notify('error', f"REAL TRADE FAILED: {symbol} | {e}", "REAL_TRADE_ERROR")        return Nonedef insert_signal_into_db(signal_data: Dict) -> Optional[Dict]:    """Ø¥Ø¯Ø±Ø§Ø¬ Ø¥Ø´Ø§Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª."""    if not check_db_connection() or not conn: return None    try:        with conn.cursor() as cur:            cur.execute("""                INSERT INTO signals (symbol, entry_price, target_price, stop_loss, strategy_name, signal_details, is_real_trade, quantity, order_id)                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING *;            """, (                signal_data['symbol'], signal_data['entry_price'], signal_data['target_price'],                signal_data['stop_loss'], signal_data['strategy_name'], json.dumps(signal_data['signal_details']),                signal_data.get('is_real_trade', False), signal_data.get('quantity'), signal_data.get('order_id')            ))            saved_signal = cur.fetchone()            conn.commit()            logger.info(f"ğŸ’¾ [{signal_data['symbol']}] ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.")            return dict(saved_signal)    except Exception as e:        logger.error(f"âŒ [DB Insert] ÙØ´Ù„ Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©: {e}")        if conn: conn.rollback()        return None# ---------------------- Ø¯ÙˆØ§Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ----------------------def determine_market_state_enhanced():    """ØªØ­Ø¯ÙŠØ¯ Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ø¹Ø§Ù…Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø·Ø± Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†."""    global current_market_state, last_market_state_check        with market_state_lock:        if time.time() - last_market_state_check < 180: # ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 3 Ø¯Ù‚Ø§Ø¦Ù‚            return        logger.info("ğŸ§  [Enhanced Market State] ØªØ­Ø¯ÙŠØ« Ø´Ø§Ù…Ù„ Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚...")        try:        trend_details = {}        for tf in TIMEFRAMES_FOR_TREND_LIGHTS:            days_to_fetch = 3 if tf == '15m' else (5 if tf == '1h' else 20)            df = fetch_historical_data(BTC_SYMBOL, tf, days_to_fetch)                        if df is not None:                # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø§ØªØ¬Ø§Ù‡                ema_fast = df['close'].ewm(span=12, adjust=False).mean().iloc[-1]                ema_slow = df['close'].ewm(span=26, adjust=False).mean().iloc[-1]                adx_df = calculate_features(df, None)                adx = adx_df['adx'].iloc[-1] if not adx_df.empty else 0                trend = "Uncertain"                if ema_fast > ema_slow and adx > 25: trend = "Strong Uptrend"                elif ema_fast > ema_slow: trend = "Uptrend"                elif ema_fast < ema_slow and adx > 25: trend = "Strong Downtrend"                elif ema_fast < ema_slow: trend = "Downtrend"                else: trend = "Ranging"                trend_details[tf] = {"trend": trend, "adx": float(adx)}            else:                trend_details[tf] = {"trend": "Uncertain", "adx": 0}            time.sleep(0.1)                trends = [details['trend'] for details in trend_details.values()]        trend_counts = {t: trends.count(t) for t in set(trends)}        overall_regime = max(trend_counts, key=trend_counts.get)                with market_state_lock:            current_market_state = {                "overall_regime": overall_regime.upper().replace(" ", "_"),                "trend_details_by_tf": trend_details,                "last_updated": datetime.now(timezone.utc).isoformat()            }            last_market_state_check = time.time()                    logger.info(f"âœ… [Enhanced Market State] Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø©: {overall_regime}")            except Exception as e:        logger.error(f"âŒ [Enhanced Market State] Ø®Ø·Ø£: {e}", exc_info=True)        with market_state_lock:            current_market_state['overall_regime'] = "RANGING"def analyze_market_and_create_dynamic_profile_enhanced():    """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ ÙˆØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ù ÙÙ„Ø§ØªØ± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ."""    global dynamic_filter_profile_cache, last_dynamic_filter_analysis_time        with dynamic_filter_lock:        if time.time() - last_dynamic_filter_analysis_time < DYNAMIC_FILTER_ANALYSIS_INTERVAL:            return        logger.info("ğŸ”¬ [Enhanced Filter] ØªØ­Ù„ÙŠÙ„ Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚ ÙˆØªÙˆÙ„ÙŠØ¯ ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙØ©...")        with force_momentum_lock:        is_forced = force_momentum_strategy        if is_forced:        logger.warning("âš ï¸ [OVERRIDE] Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø²Ø®Ù… Ù…ÙØ±ÙˆØ¶Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹")        base_profile = {"adx": 25.0, "rel_vol": 0.4, "rsi_range": (52, 88), "roc": 0.05, "slope": 0.01, "min_rrr": 1.4, "min_volatility_pct": 0.35, "min_btc_correlation": 0.4, "min_bid_ask_ratio": 1.15}        description = "Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø²Ø®Ù… Ù…ÙØ±ÙˆØ¶Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹"    else:        enhanced_profile = enhanced_filter_system.generate_filters()        description = enhanced_profile['description']        base_profile = enhanced_profile['filters']    with dynamic_filter_lock:        dynamic_filter_profile_cache = {            "name": description,            "description": description,            "strategy": "MOMENTUM",            "filters": base_profile,            "last_updated": datetime.now(timezone.utc).isoformat(),        }        last_dynamic_filter_analysis_time = time.time()        logger.info(f"âœ… [Enhanced Filter] ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙØ© Ø¬Ø¯ÙŠØ¯Ø©: {description}")# ---------------------- ÙˆØ§Ø¬Ù‡Ø© Flask ----------------------app = Flask(__name__)CORS(app)def get_dashboard_html():    # Ù‡Ø°Ø§ Ù‡Ùˆ Ù‚Ø§Ù„Ø¨ HTML Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ø¹ JavaScript Ø§Ù„Ù…Ø¯Ù…Ø¬    return """<!DOCTYPE html><html lang="ar" dir="rtl"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„ØªØ¯Ø§ÙˆÙ„ V28</title>    <script src="https://cdn.tailwindcss.com"></script>    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700;800&display=swap" rel="stylesheet">    <style>        :root {            --bg-main: #0D1117; --bg-card: #161B22; --border-color: #30363D;            --text-primary: #E6EDF3; --text-secondary: #848D97;            --accent-blue: #58A6FF; --accent-green: #3FB950; --accent-red: #F85149; --accent-yellow: #D29922;        }        body { font-family: 'Tajawal', sans-serif; background-color: var(--bg-main); color: var(--text-primary); }        .card { background-color: var(--bg-card); border: 1px solid var(--border-color); border-radius: 0.5rem; transition: all 0.3s ease; }        .card:hover { border-color: var(--accent-blue); }        .trend-light { width: 1rem; height: 1rem; border-radius: 9999px; border: 2px solid rgba(255, 255, 255, 0.1); transition: background-color 0.5s ease, box-shadow 0.5s ease; }        .light-off { background-color: #30363D; }        .light-on-green { background-color: var(--accent-green); box-shadow: 0 0 10px 2px var(--accent-green); }        .light-on-red { background-color: var(--accent-red); box-shadow: 0 0 10px 2px var(--accent-red); }        .light-on-yellow { background-color: var(--accent-yellow); box-shadow: 0 0 10px 2px var(--accent-yellow); }        .tab-btn { border-bottom: 2px solid transparent; }        .tab-btn.active { border-bottom-color: var(--accent-blue); }        .toggle-bg { transition: background-color .2s ease-in-out; }        input:checked + .toggle-bg { background-color: var(--accent-green); }    </style></head><body class="p-4 md:p-6">    <div class="container mx-auto max-w-screen-2xl">        <header class="mb-6 flex flex-wrap justify-between items-center gap-4">            <h1 class="text-2xl md:text-3xl font-extrabold text-white">                <span class="text-accent-blue">Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„ØªØ¯Ø§ÙˆÙ„</span>                <span class="text-text-secondary font-medium">V28</span>            </h1>            <div id="trend-lights-container" class="flex items-center gap-x-6 bg-black/20 px-4 py-2 rounded-lg border border-border-color"></div>        </header>                <section class="mb-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-5">            <div class="card p-4">                <h3 class="font-bold mb-3 text-lg text-text-secondary">Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚ (BTC)</h3>                <div id="overall-regime" class="text-2xl font-bold text-center">...</div>            </div>            <div class="card p-4">                <h3 class="font-bold mb-3 text-lg text-text-secondary">Ù…Ù„Ù Ø§Ù„ÙÙ„Ø§ØªØ±</h3>                <div id="filter-profile-name" class="text-xl font-bold text-center">...</div>            </div>            <div class="card p-4">                <h3 class="font-bold mb-3 text-lg text-text-secondary">Ø§Ù„Ø¨ÙˆØ±ØµØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©</h3>                <div id="active-sessions-list" class="flex flex-wrap gap-2 items-center justify-center pt-2">...</div>            </div>            <div class="card p-4 flex flex-col justify-center items-center">                <h3 class="font-bold text-lg text-text-secondary mb-2">Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ</h3>                <div class="flex items-center space-x-3 space-x-reverse">                    <span id="trading-status-text" class="font-bold text-lg text-accent-red">ØºÙŠØ± Ù…ÙÙØ¹Ù‘ÙÙ„</span>                    <label class="flex items-center cursor-pointer">                        <div class="relative"><input type="checkbox" id="trading-toggle" class="sr-only" onchange="toggleTrading()"><div class="toggle-bg block bg-gray-600 w-12 h-7 rounded-full"></div></div>                    </label>                </div>                <div class="mt-2 text-xs text-text-secondary">Ø±ØµÙŠØ¯ USDT: <span id="usdt-balance" class="font-mono">...</span></div>            </div>            <div class="card p-4 flex flex-col justify-center items-center bg-blue-900/20 border-accent-blue">                <h3 class="font-bold text-lg text-text-secondary mb-2">Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©</h3>                <div class="flex items-center space-x-3 space-x-reverse">                    <span id="force-momentum-text" class="font-bold text-lg text-text-secondary">ØªÙ„Ù‚Ø§Ø¦ÙŠ</span>                    <label class="flex items-center cursor-pointer">                        <div class="relative"><input type="checkbox" id="force-momentum-toggle" class="sr-only" onchange="toggleMomentumStrategy()"><div class="toggle-bg block bg-gray-600 w-12 h-7 rounded-full"></div></div>                    </label>                </div>            </div>        </section>        <div class="mb-4 border-b border-border-color">            <nav class="flex space-x-6 space-x-reverse -mb-px">                <button onclick="showTab('signals', this)" class="tab-btn active text-white py-3 px-1 font-semibold">Ø§Ù„ØµÙÙ‚Ø§Øª</button>                <button onclick="showTab('stats', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</button>                <button onclick="showTab('notifications', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª</button>                <button onclick="showTab('rejections', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©</button>                <button onclick="showTab('filters', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ©</button>            </nav>        </div>        <main>            <div id="signals-tab" class="tab-content">                <div class="overflow-x-auto card p-0"><table class="min-w-full text-sm text-right"><thead class="border-b border-border-color bg-black/20"><tr><th class="p-4 font-semibold">Ø§Ù„Ø¹Ù…Ù„Ø©</th><th class="p-4 font-semibold">Ø§Ù„Ø­Ø§Ù„Ø©</th><th class="p-4 font-semibold">Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø©</th><th class="p-4 font-semibold w-[25%]">Ø§Ù„ØªÙ‚Ø¯Ù…</th><th class="p-4 font-semibold">Ø§Ù„Ø¯Ø®ÙˆÙ„/Ø§Ù„Ø­Ø§Ù„ÙŠ</th></tr></thead><tbody id="signals-table"></tbody></table></div>            </div>            <div id="stats-tab" class="tab-content hidden"><div id="stats-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4"></div></div>            <div id="notifications-tab" class="tab-content hidden"><div id="notifications-list" class="card p-4 max-h-[60vh] overflow-y-auto space-y-2"></div></div>            <div id="rejections-tab" class="tab-content hidden"><div id="rejections-list" class="card p-4 max-h-[60vh] overflow-y-auto space-y-2"></div></div>            <div id="filters-tab" class="tab-content hidden"><div id="filters-display" class="card p-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div></div>        </main>    </div><script>// --- ÙƒÙˆØ¯ Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… ---function showTab(tabId, element) {    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));    document.getElementById(tabId + '-tab').classList.remove('hidden');    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active', 'text-white'));    element.classList.add('active', 'text-white');}async function fetchData(url) {    try {        const response = await fetch(url);        if (!response.ok) {            console.error(`HTTP error! status: ${response.status}`);            return null;        }        return await response.json();    } catch (error) {        console.error('Fetch error:', error);        return null;    }}function updateMarketStatus() {    fetchData('/api/market_status').then(data => {        if (!data) return;                // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚        const regime = data.market_state?.overall_regime || 'UNCERTAIN';        const regimeText = regime.replace(/_/g, ' ');        document.getElementById('overall-regime').textContent = regimeText;                // ØªØ­Ø¯ÙŠØ« Ø£Ø¶ÙˆØ§Ø¡ Ø§Ù„Ø§ØªØ¬Ø§Ù‡        const lightsContainer = document.getElementById('trend-lights-container');        lightsContainer.innerHTML = '';        const trendDetails = data.market_state?.trend_details_by_tf || {};        ['15m', '1h', '4h'].forEach(tf => {            const trend = trendDetails[tf]?.trend || 'Uncertain';            let colorClass = 'light-off';            if (trend.includes('Uptrend')) colorClass = 'light-on-green';            else if (trend.includes('Downtrend')) colorClass = 'light-on-red';            else if (trend.includes('Ranging')) colorClass = 'light-on-yellow';                        lightsContainer.innerHTML += `                <div class="flex items-center gap-2" title="Ø§ØªØ¬Ø§Ù‡ ${tf}">                    <div class="trend-light ${colorClass}"></div>                    <span class="text-sm font-bold text-text-secondary">${tf}</span>                </div>`;        });        // ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù Ø§Ù„ÙÙ„Ø§ØªØ±        document.getElementById('filter-profile-name').textContent = data.filter_profile?.name || 'ØºÙŠØ± Ù…ØªØ§Ø­';        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©        const sessionsList = document.getElementById('active-sessions-list');        if (data.active_sessions && data.active_sessions.length > 0) {            sessionsList.innerHTML = data.active_sessions.map(s => `<span class="bg-accent-blue/20 text-accent-blue text-xs font-bold px-2 py-1 rounded">${s}</span>`).join('');        } else {            sessionsList.innerHTML = `<span class="bg-gray-700 text-text-secondary text-xs font-bold px-2 py-1 rounded">Ù„Ø§ ØªÙˆØ¬Ø¯</span>`;        }        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø§ÙˆÙ„        const tradingToggle = document.getElementById('trading-toggle');        const tradingStatusText = document.getElementById('trading-status-text');        tradingToggle.checked = data.is_trading_enabled;        tradingStatusText.textContent = data.is_trading_enabled ? 'Ù…ÙÙØ¹Ù‘ÙÙ„' : 'ØºÙŠØ± Ù…ÙÙØ¹Ù‘ÙÙ„';        tradingStatusText.className = data.is_trading_enabled ? 'font-bold text-lg text-accent-green' : 'font-bold text-lg text-accent-red';        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµÙŠØ¯        document.getElementById('usdt-balance').textContent = data.usdt_balance ? parseFloat(data.usdt_balance).toFixed(2) : 'N/A';                // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© ÙØ±Ø¶ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©        const momentumToggle = document.getElementById('force-momentum-toggle');        const momentumText = document.getElementById('force-momentum-text');        momentumToggle.checked = data.force_momentum_enabled;        momentumText.textContent = data.force_momentum_enabled ? 'Ù…ÙØ±ÙˆØ¶' : 'ØªÙ„Ù‚Ø§Ø¦ÙŠ';    });}function updateSignals() {    fetchData('/api/signals').then(data => {        if (!data) return;        const tableBody = document.getElementById('signals-table');        tableBody.innerHTML = '';        const openSignals = data.filter(s => ['open', 'updated'].includes(s.status));                openSignals.forEach(signal => {            const profitPct = parseFloat(signal.profit_percentage || 0);            const profitClass = profitPct > 0 ? 'text-accent-green' : (profitPct < 0 ? 'text-accent-red' : 'text-text-secondary');                        const entry = parseFloat(signal.entry_price);            const sl = parseFloat(signal.stop_loss);            const tp = parseFloat(signal.target_price);            const currentPrice = parseFloat(signal.current_price || entry);                        const progress = Math.max(0, Math.min(100, (currentPrice - sl) / (tp - sl) * 100));            tableBody.innerHTML += `                <tr class="border-b border-border-color hover:bg-white/5">                    <td class="p-4 font-bold">${signal.symbol}</td>                    <td class="p-4"><span class="px-2 py-1 text-xs font-semibold rounded-full ${signal.is_real_trade ? 'bg-blue-500/20 text-blue-400' : 'bg-yellow-500/20 text-yellow-400'}">${signal.is_real_trade ? 'Ø­Ù‚ÙŠÙ‚ÙŠ' : 'ØªØ¬Ø±ÙŠØ¨ÙŠ'}</span></td>                    <td class="p-4 font-mono ${profitClass}">${profitPct.toFixed(2)}%</td>                    <td class="p-4">                        <div class="w-full bg-gray-700 rounded-full h-2.5">                            <div class="bg-accent-blue h-2.5 rounded-full" style="width: ${progress}%"></div>                        </div>                    </td>                    <td class="p-4 font-mono">${currentPrice.toFixed(4)} / ${entry.toFixed(4)}</td>                </tr>`;        });    });}function updateStats() {    fetchData('/api/stats').then(data => {        if (!data) return;        const container = document.getElementById('stats-container');        container.innerHTML = `            <div class="card p-4 text-center"><h4 class="text-text-secondary">ØµØ§ÙÙŠ Ø§Ù„Ø±Ø¨Ø­ (USDT)</h4><div class="text-2xl font-bold ${data.net_profit_usdt >= 0 ? 'text-accent-green' : 'text-accent-red'}">${parseFloat(data.net_profit_usdt).toFixed(2)}</div></div>            <div class="card p-4 text-center"><h4 class="text-text-secondary">Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø±Ø¨Ø­</h4><div class="text-2xl font-bold">${parseFloat(data.win_rate).toFixed(2)}%</div></div>            <div class="card p-4 text-center"><h4 class="text-text-secondary">Ø¹Ø§Ù…Ù„ Ø§Ù„Ø±Ø¨Ø­</h4><div class="text-2xl font-bold">${data.profit_factor === 'Infinity' ? 'âˆ' : parseFloat(data.profit_factor).toFixed(2)}</div></div>            <div class="card p-4 text-center"><h4 class="text-text-secondary">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ØºÙ„Ù‚Ø©</h4><div class="text-2xl font-bold">${data.total_closed_trades}</div></div>        `;    });}function updateNotifications() {    fetchData('/api/notifications').then(data => {        if (!data) return;        const list = document.getElementById('notifications-list');        list.innerHTML = data.map(n => {            let color = 'text-text-secondary';            if (n.type.includes('ERROR') || n.type.includes('FAIL')) color = 'text-accent-red';            else if (n.type.includes('REAL_TRADE')) color = 'text-accent-blue';            else if (n.type.includes('SUCCESS')) color = 'text-accent-green';            return `<div class="p-2 border-b border-border-color"><span class="font-mono text-xs ${color}">${new Date(n.timestamp).toLocaleString('ar-EG')}</span>: ${n.message}</div>`;        }).join('');    });}function updateRejections() {    fetchData('/api/rejection_logs').then(data => {        if (!data) return;        const list = document.getElementById('rejections-list');        list.innerHTML = data.map(r => `            <div class="p-2 border-b border-border-color">                <span class="font-mono text-xs text-text-secondary">${new Date(r.timestamp).toLocaleString('ar-EG')}</span>:                 <strong class="text-accent-yellow">${r.symbol}</strong> - ${r.reason}                <span class="text-xs text-gray-500">${JSON.stringify(r.details)}</span>            </div>`).join('');    });}function updateFilters() {     fetchData('/api/market_status').then(data => {        if (!data || !data.filter_profile || !data.filter_profile.filters) return;        const container = document.getElementById('filters-display');        const filters = data.filter_profile.filters;        container.innerHTML = Object.entries(filters).map(([key, value]) => `            <div class="card p-3 bg-black/20">                <div class="text-sm text-text-secondary">${key}</div>                <div class="font-bold text-lg text-accent-blue">${Array.isArray(value) ? `(${value.join(', ')})` : value}</div>            </div>        `).join('');    });}function toggleTrading() {    fetch('/api/trading/toggle', { method: 'POST' }).then(() => updateMarketStatus());}function toggleMomentumStrategy() {    fetch('/api/strategy/force_momentum/toggle', { method: 'POST' }).then(() => updateMarketStatus());}// --- Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø¯ÙˆØ±ÙŠØ© ---document.addEventListener('DOMContentLoaded', () => {    updateMarketStatus();    updateSignals();    updateStats();    updateNotifications();    updateRejections();    updateFilters();    setInterval(updateMarketStatus, 5000); // ÙƒÙ„ 5 Ø«ÙˆØ§Ù†    setInterval(updateSignals, 10000); // ÙƒÙ„ 10 Ø«ÙˆØ§Ù†    setInterval(updateStats, 60000); // ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©    setInterval(updateNotifications, 15000);    setInterval(updateRejections, 15000);    setInterval(updateFilters, 60000);});</script></body></html>"""@app.route('/')def home():    return render_template_string(get_dashboard_html())@app.route('/api/market_status')def get_market_status():    with market_state_lock:        state_copy = dict(current_market_state)    with force_momentum_lock:        is_forced = force_momentum_strategy    with trading_status_lock:        is_enabled = is_trading_enabled    with dynamic_filter_lock:        profile_copy = dict(dynamic_filter_profile_cache)            active_sessions, _, _ = get_session_state()    usdt_balance = None    if client:        try:            usdt_balance = float(client.get_asset_balance(asset='USDT')['free'])        except Exception as e:            logger.warning(f"Could not fetch USDT balance: {e}")    return jsonify({        "market_state": state_copy,        "filter_profile": profile_copy,        "active_sessions": active_sessions,        "db_ok": check_db_connection(),        "api_ok": True if client else False,        "usdt_balance": usdt_balance,        "is_trading_enabled": is_enabled,        "force_momentum_enabled": is_forced    })@app.route('/api/stats')def get_stats():    if not check_db_connection(): return jsonify({"error": "DB connection failed"}), 500    try:        with conn.cursor() as cur:            cur.execute("SELECT status, profit_percentage, is_real_trade, quantity, entry_price FROM signals WHERE status = 'closed';")            closed_trades = cur.fetchall()                if not closed_trades:            return jsonify({                "net_profit_usdt": 0, "win_rate": 0, "profit_factor": 0,                "total_closed_trades": 0, "average_win_pct": 0, "average_loss_pct": 0            })        total_net_profit_usdt = 0.0        for t in closed_trades:            profit_pct = float(t['profit_percentage']) - (2 * TRADING_FEE_PERCENT)            trade_size = STATS_TRADE_SIZE_USDT            if t.get('is_real_trade') and t.get('quantity') and t.get('entry_price'):                trade_size = float(t['quantity']) * float(t['entry_price'])            total_net_profit_usdt += (profit_pct / 100) * trade_size                wins_list = [float(s['profit_percentage']) for s in closed_trades if float(s['profit_percentage']) > 0]        losses_list = [float(s['profit_percentage']) for s in closed_trades if float(s['profit_percentage']) < 0]        win_rate = (len(wins_list) / len(closed_trades) * 100) if closed_trades else 0.0        avg_win = sum(wins_list) / len(wins_list) if wins_list else 0.0        avg_loss = sum(losses_list) / len(losses_list) if losses_list else 0.0        profit_factor_val = sum(wins_list) / abs(sum(losses_list)) if abs(sum(losses_list)) > 0 else "Infinity"        return jsonify({            "net_profit_usdt": total_net_profit_usdt,            "win_rate": win_rate,            "profit_factor": profit_factor_val,            "total_closed_trades": len(closed_trades),            "average_win_pct": avg_win,            "average_loss_pct": avg_loss        })    except Exception as e:        logger.error(f"âŒ [API Stats] Error: {e}", exc_info=True)        if conn: conn.rollback()        return jsonify({"error": "Internal error in stats"}), 500@app.route('/api/signals')def get_signals():    if not all([check_db_connection(), redis_client, client]):        return jsonify({"error": "Service connection failed"}), 500    try:        current_prices = redis_client.hgetall(REDIS_PRICES_HASH_NAME)        with conn.cursor() as cur:            cur.execute("SELECT * FROM signals ORDER BY CASE WHEN status IN ('open', 'updated') THEN 0 ELSE 1 END, id DESC;")            all_signals = [dict(s) for s in cur.fetchall()]                for signal in all_signals:            if signal['status'] in ['open', 'updated']:                current_price = current_prices.get(signal['symbol'])                if current_price:                    signal['current_price'] = current_price                    entry = float(signal['entry_price'])                    signal['profit_percentage'] = ((float(current_price) - entry) / entry) * 100        return jsonify(all_signals)    except Exception as e:        logger.error(f"âŒ [API Signals] Error: {e}", exc_info=True)        if conn: conn.rollback()        return jsonify({"error": str(e)}), 500@app.route('/api/notifications')def get_notifications():    with notifications_lock:        return jsonify(list(notifications_cache))@app.route('/api/rejection_logs')def get_rejection_logs():    with rejection_logs_lock:        return jsonify(list(rejection_logs_cache))@app.route('/api/trading/toggle', methods=['POST'])def toggle_trading_status():    global is_trading_enabled    with trading_status_lock:        is_trading_enabled = not is_trading_enabled        status_msg = "ENABLED" if is_trading_enabled else "DISABLED"        log_and_notify('warning', f"ğŸš¨ Real trading status changed to: {status_msg}", "TRADING_STATUS_CHANGE")        return jsonify({"message": f"Trading status set to {status_msg}", "is_enabled": is_trading_enabled})@app.route('/api/strategy/force_momentum/toggle', methods=['POST'])def toggle_force_momentum():    global force_momentum_strategy    with force_momentum_lock:        force_momentum_strategy = not force_momentum_strategy        status_msg = "FORCED MOMENTUM" if force_momentum_strategy else "AUTOMATIC"        log_and_notify('warning', f"âš™ï¸ Strategy mode changed to: {status_msg}", "STRATEGY_MODE_CHANGE")        # Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ ÙÙˆØ±Ø§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„ØªØºÙŠÙŠØ±        Thread(target=analyze_market_and_create_dynamic_profile_enhanced).start()        return jsonify({"message": f"Strategy mode set to {status_msg}", "is_forced": force_momentum_strategy})# ---------------------- Ø­Ù„Ù‚Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… ----------------------def main_loop_enhanced():    """Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„."""    logger.info("[Enhanced Main Loop] Ø§Ù†ØªØ¸Ø§Ø± Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©...")    time.sleep(15)    if not validated_symbols_to_scan:        log_and_notify("critical", "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù…Ù„Ø§Øª ØµØ§Ù„Ø­Ø© Ù„Ù„Ù…Ø³Ø­. Ù„Ù† ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø¨ÙˆØª.", "SYSTEM")        return    log_and_notify("info", f"âœ… Ø¨Ø¯Ø¡ Ø­Ù„Ù‚Ø© Ø§Ù„Ù…Ø³Ø­ Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù„Ù€ {len(validated_symbols_to_scan)} Ø¹Ù…Ù„Ø©.", "SYSTEM")    while True:        try:            logger.info("ğŸ”„ Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© Ù…Ø³Ø­ Ù…Ø­Ø³Ù†Ø© Ø¬Ø¯ÙŠØ¯Ø©...")            ml_models_cache.clear(); gc.collect()            determine_market_state_enhanced()            analyze_market_and_create_dynamic_profile_enhanced()                        with dynamic_filter_lock:                filter_profile = dynamic_filter_profile_cache                        if not filter_profile:                logger.warning("ğŸ›‘ Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù Ø§Ù„ÙÙ„Ø§ØªØ± Ø¨Ø¹Ø¯. ØªØ®Ø·ÙŠ Ø§Ù„Ø¯ÙˆØ±Ø©.")                time.sleep(60)                continue            btc_data = get_btc_data_for_bot()                        symbols_with_models = [s for s in validated_symbols_to_scan if os.path.exists(os.path.join(os.path.dirname(os.path.abspath(__file__)), MODEL_FOLDER, f"{BASE_ML_MODEL_NAME}_{s}.pkl"))]                        if not symbols_with_models:                logger.warning("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù…Ù„Ø§Øª Ù„Ù‡Ø§ Ù†Ù…Ø§Ø°Ø¬ ØªØ¹Ù„Ù… Ø¢Ù„ÙŠ. ØªØ®Ø·ÙŠ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø³Ø­.")                time.sleep(300)                continue                            symbols_to_process = random.sample(symbols_with_models, len(symbols_with_models))                        processed_count = 0            for symbol in symbols_to_process:                try:                    with signal_cache_lock:                        if symbol in open_signals_cache or len(open_signals_cache) >= MAX_OPEN_TRADES:                            continue                                        df_15m = fetch_historical_data(symbol, SIGNAL_GENERATION_TIMEFRAME, SIGNAL_GENERATION_LOOKBACK_DAYS)                    if df_15m is None or df_15m.empty: continue                                        strategy = EnhancedTradingStrategy(symbol)                    if not all([strategy.ml_model, strategy.scaler, strategy.feature_names]): continue                                        df_4h = fetch_historical_data(symbol, '4h', SIGNAL_GENERATION_LOOKBACK_DAYS)                    if df_4h is None or df_4h.empty: continue                                        df_features = strategy.get_features(df_15m, df_4h, btc_data)                    if df_features is None or df_features.empty: continue                                        ml_signal = strategy.generate_buy_signal(df_features)                                        if not ml_signal or ml_signal['confidence'] < BUY_CONFIDENCE_THRESHOLD:                        continue                                        try:                        entry_price = float(client.get_symbol_ticker(symbol=symbol)['price'])                    except Exception as e:                        logger.error(f"âŒ [{symbol}] Ù„Ù… ÙŠØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„: {e}. ØªØ®Ø·ÙŠ.")                        continue                    last_features = df_features.iloc[-1]                    last_atr = last_features.get('atr', 0)                    tp_sl_data = calculate_tp_sl(symbol, entry_price, last_atr)                                        if not tp_sl_data or not passes_filters(symbol, last_features, filter_profile, entry_price, tp_sl_data, df_15m):                        continue                    order_book_analysis = analyze_order_book(symbol, entry_price)                    if not order_book_analysis or not passes_order_book_check(symbol, order_book_analysis, filter_profile):                        continue                                        new_signal = {                        'symbol': symbol, 'strategy_name': "Momentum_ML_Enhanced",                        'signal_details': {                            'ML_Confidence': f"{ml_signal['confidence']:.2%}",                            'Filter_Profile': f"{filter_profile['name']}",                            'Bid_Ask_Ratio': order_book_analysis.get('bid_ask_ratio', 0),                        },                        'entry_price': entry_price, **tp_sl_data                    }                                        with trading_status_lock: is_enabled = is_trading_enabled                    if is_enabled:                        quantity = calculate_position_size(symbol, entry_price, new_signal['stop_loss'])                        if quantity and quantity > 0:                            order_result = place_order(symbol, Client.SIDE_BUY, quantity)                            if order_result:                                new_signal.update({'is_real_trade': True, 'quantity': float(quantity), 'order_id': order_result['orderId']})                            else: continue                        else: continue                    else:                        new_signal['is_real_trade'] = False                    saved_signal = insert_signal_into_db(new_signal)                    if saved_signal:                        with signal_cache_lock:                            open_signals_cache[saved_signal['symbol']] = saved_signal                        log_and_notify('info', f"SIGNAL: New buy signal for {symbol} at {entry_price}", "NEW_SIGNAL")                except Exception as e:                    logger.error(f"âŒ [Enhanced Processing Error] Ù„Ù„Ø¹Ù…Ù„Ø© {symbol}: {e}", exc_info=True)                finally:                    processed_count += 1                    if processed_count % SYMBOL_PROCESSING_BATCH_SIZE == 0:                        logger.info("ğŸ“¦ ØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¯ÙØ¹Ø©. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©...")                        ml_models_cache.clear(); gc.collect()                        time.sleep(2)                    time.sleep(0.75)                        logger.info("âœ… [Enhanced End of Cycle] Ø§Ù†ØªÙ‡Øª Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø³Ø­ Ø§Ù„ÙƒØ§Ù…Ù„Ø©.")            gc.collect()            logger.info(f"â³ [Enhanced End of Cycle] Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù…Ø¯Ø© 60 Ø«Ø§Ù†ÙŠØ©...")            time.sleep(60)        except (KeyboardInterrupt, SystemExit):            log_and_notify("info", "Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….", "SYSTEM")            break        except Exception as main_err:            log_and_notify("error", f"Ø®Ø·Ø£ Ø­Ø±Ø¬ ÙÙŠ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø©: {main_err}", "SYSTEM")            time.sleep(120)def price_update_loop():    """Ø­Ù„Ù‚Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙÙŠ Redis."""    if not redis_client:        logger.error("Redis client not initialized. Price update loop cannot start.")        return        while True:        try:            if validated_symbols_to_scan:                tickers = client.get_symbol_ticker()                prices_to_set = {t['symbol']: t['price'] for t in tickers if t['symbol'] in validated_symbols_to_scan}                if prices_to_set:                    redis_client.hset(REDIS_PRICES_HASH_NAME, mapping=prices_to_set)            time.sleep(2) # ØªØ­Ø¯ÙŠØ« ÙƒÙ„ Ø«Ø§Ù†ÙŠØªÙŠÙ†        except Exception as e:            logger.error(f"Error in price update loop: {e}")            time.sleep(10)def initialize_bot_services():    """ØªÙ‡ÙŠØ¦Ø© Ø¬Ù…ÙŠØ¹ Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ù„ÙÙŠØ©."""    global client, validated_symbols_to_scan    logger.info("ğŸ¤– [Bot Services] Ø¨Ø¯Ø¡ Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø©...")    try:        client = Client(API_KEY, API_SECRET)        init_db()        init_redis()        get_exchange_info_map()        load_open_signals_to_cache()        load_notifications_to_cache()                validated_symbols_to_scan = get_validated_symbols()        if not validated_symbols_to_scan:            logger.critical("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù…Ù„Ø§Øª ØµØ§Ù„Ø­Ø© Ù„Ù„Ù…Ø³Ø­. Ù„Ù† ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø¨ÙˆØª.")            return                # Ø¨Ø¯Ø¡ Ø§Ù„Ø­Ù„Ù‚Ø§Øª ÙÙŠ threads Ù…Ù†ÙØµÙ„Ø©        Thread(target=main_loop_enhanced, daemon=True).start()        Thread(target=price_update_loop, daemon=True).start()                logger.info("âœ… [Bot Services] ØªÙ… Ø¨Ø¯Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ø¨Ù†Ø¬Ø§Ø­.")    except Exception as e:        log_and_notify("critical", f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø­Ø±Ø¬ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©: {e}", "SYSTEM")        exit(1)# ---------------------- Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù†Ø·Ù„Ø§Ù‚ ----------------------if __name__ == "__main__":    logger.info("ğŸš€ Ø¥Ø·Ù„Ø§Ù‚ Ø¨ÙˆØª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ ÙˆÙ„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø­Ø³Ù†Ø© (V28 - Ù†Ø³Ø®Ø© ÙƒØ§Ù…Ù„Ø©) ğŸš€")    initialization_thread = Thread(target=initialize_bot_services, daemon=True)    initialization_thread.start()        port = int(os.environ.get('PORT', 10000))    host = "0.0.0.0"    logger.info(f"âœ… Ø§Ù„ØªØ­Ø¶ÙŠØ± Ù„Ø¨Ø¯Ø¡ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¹Ù„Ù‰ {host}:{port}")    try:        from waitress import serve        serve(app, host=host, port=port, threads=8)    except ImportError:        logger.warning("âš ï¸ 'waitress' ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø§Ø¯Ù… Ø§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ø®Ø§Øµ Ø¨Ù€ Flask.")        app.run(host=host, port=port)    logger.info("ğŸ‘‹ [Shutdown] ØªÙ… Ø¥ÙŠÙ‚Ø§Ù ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚.")