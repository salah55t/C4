# Ù…Ù„Ù c4_enhanced_v28.py - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© V28import timeimport osimport jsonimport loggingimport requestsimport numpy as npimport pandas as pdimport psycopg2import pickleimport redisimport reimport gcimport randomfrom decimal import Decimal, ROUND_DOWNfrom urllib.parse import urlparsefrom psycopg2 import sql, OperationalError, InterfaceErrorfrom psycopg2.extras import RealDictCursorfrom binance.client import Clientfrom binance import ThreadedWebsocketManagerfrom binance.exceptions import BinanceAPIExceptionfrom flask import Flask, request, Response, jsonify, render_template_stringfrom flask_cors import CORSfrom threading import Thread, Lockfrom datetime import datetime, timedelta, timezonefrom decouple import configfrom typing import List, Dict, Optional, Any, Set, Tuplefrom sklearn.preprocessing import StandardScalerfrom collections import dequeimport warnings# --- ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª ---warnings.simplefilter(action='ignore', category=FutureWarning)warnings.simplefilter(action='ignore', category=UserWarning)# ---------------------- Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ (Logging) - V28 (Enhanced Filters) ----------------------logging.basicConfig(    level=logging.INFO,    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',    handlers=[        logging.FileHandler('crypto_bot_v28_enhanced_logs.log', encoding='utf-8'),        logging.StreamHandler()    ])logger = logging.getLogger('CryptoBotV28')# ---------------------- ØªØ­Ù…ÙŠÙ„ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© ----------------------try:    API_KEY: str = config('BINANCE_API_KEY')    API_SECRET: str = config('BINANCE_API_SECRET')    TELEGRAM_TOKEN: str = config('TELEGRAM_BOT_TOKEN')    CHAT_ID: str = config('TELEGRAM_CHAT_ID')    DB_URL: str = config('DATABASE_URL')    WEBHOOK_URL: Optional[str] = config('WEBHOOK_URL', default=None)    REDIS_URL: str = config('REDIS_URL', default='redis://localhost:6379/0')except Exception as e:    logger.critical(f"âŒ ÙØ´Ù„ Ø­Ø§Ø³Ù… ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©: {e}")    exit(1)# ---------------------- Ø£Ù†Ø¸Ù…Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ----------------------class EnhancedTrendAnalyzer:    """Ù†Ø¸Ø§Ù… Ù…ØªÙ‚Ø¯Ù… Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯"""        @staticmethod    def get_enhanced_trend(df: pd.DataFrame, symbol: str, btc_df: pd.DataFrame) -> Dict[str, Any]:        """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø­Ø³Ù†"""        if df is None or len(df) < 50 or btc_df is None:            return {"trend": "Uncertain", "strength": 0, "confidence": 0}                try:            close_series = df['close']            btc_close = btc_df['close']                        # 1. Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ù†Ø³Ø¨ÙŠØ© Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨ BTC            symbol_returns = close_series.pct_change()            btc_returns = btc_close.pct_change()            relative_strength = (symbol_returns - btc_returns).tail(20).mean() * 100                        # 2. MACD Ø§Ù„Ù…ØªÙ‚Ø¯Ù…            exp1 = close_series.ewm(span=12, adjust=False).mean()            exp2 = close_series.ewm(span=26, adjust=False).mean()            macd = exp1 - exp2            signal_line = macd.ewm(span=9, adjust=False).mean()            macd_histogram = macd - signal_line                        # 3. ADX Ø§Ù„Ù…ØªÙ‚Ø¯Ù…            adx_value = EnhancedTrendAnalyzer._calculate_advanced_adx(df)                        # 4. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¬Ù…            volume_strength = EnhancedTrendAnalyzer._analyze_volume_pattern(df)                        # 5. Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹ÙˆÙ… ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø§Øª            support_resistance = EnhancedTrendAnalyzer._find_dynamic_sr_levels(df)                        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©            trend_score = 0                        # MACD Signal            if macd.iloc[-1] > signal_line.iloc[-1]:                trend_score += 0.25            else:                trend_score -= 0.25                        # MACD Histogram            if macd_histogram.iloc[-1] > 0:                trend_score += 0.20            else:                trend_score -= 0.20                        # ADX + Relative Strength            adx_contribution = min(adx_value / 50, 1) * (1 if relative_strength > 0 else -1) * 0.30            trend_score += adx_contribution                        # Volume            trend_score += volume_strength * 0.15                        # Support/Resistance            current_price = close_series.iloc[-1]            if current_price > support_resistance['pivot']:                trend_score += 0.10            else:                trend_score -= 0.10                        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø©            if abs(trend_score) >= 0.7:                trend = "Strong Uptrend" if trend_score > 0 else "Strong Downtrend"            elif abs(trend_score) >= 0.3:                trend = "Uptrend" if trend_score > 0 else "Downtrend"            else:                trend = "Ranging"                        return {                "trend": trend,                "strength": abs(trend_score),                "confidence": min(abs(trend_score) * 100, 100),                "relative_strength": relative_strength,                "adx": adx_value,                "volume_score": volume_strength,                "support": support_resistance['support'],                "resistance": support_resistance['resistance']            }                    except Exception as e:            logger.error(f"âŒ [Enhanced Trend] Ø®Ø·Ø£ ÙÙŠ {symbol}: {e}")            return {"trend": "Uncertain", "strength": 0, "confidence": 0}        @staticmethod    def _calculate_advanced_adx(df: pd.DataFrame) -> float:        """Ø­Ø³Ø§Ø¨ ADX Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""        try:            high, low, close = df['high'], df['low'], df['close']                        # True Range            tr1 = high - low            tr2 = abs(high - close.shift())            tr3 = abs(low - close.shift())            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)                        # Directional Movement            plus_dm = np.where((high > high.shift()) & ((high - high.shift()) > (low.shift() - low)),                              high - high.shift(), 0)            minus_dm = np.where((low < low.shift()) & ((low.shift() - low) > (high - high.shift())),                               low.shift() - low, 0)                        # Smoothed values            atr = tr.rolling(window=14).mean()            plus_di = 100 * (pd.Series(plus_dm).rolling(window=14).mean() / atr)            minus_di = 100 * (pd.Series(minus_dm).rolling(window=14).mean() / atr)                        dx = 100 * abs(plus_di - minus_di) / (plus_di + minus_di)            adx = dx.rolling(window=14).mean()                        return adx.iloc[-1] if not adx.empty else 0                    except Exception:            return 0        @staticmethod    def _analyze_volume_pattern(df: pd.DataFrame) -> float:        """ØªØ­Ù„ÙŠÙ„ Ù†Ù…Ø· Ø­Ø¬Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„"""        try:            volume = df['volume']            price = df['close']                        avg_volume = volume.rolling(window=20).mean()            current_ratio = volume.iloc[-1] / avg_volume.iloc[-1] if avg_volume.iloc[-1] > 0 else 1                        price_change = price.pct_change().tail(5).mean()            volume_change = volume.pct_change().tail(5).mean()                        correlation = np.sign(price_change * volume_change) * min(abs(price_change * 100), 1)                        return correlation                    except Exception:            return 0        @staticmethod    def _find_dynamic_sr_levels(df: pd.DataFrame) -> Dict[str, float]:        """Ø¥ÙŠØ¬Ø§Ø¯ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©"""        try:            close = df['close']            high = df['high']            low = df['low']                        pivot = (high.iloc[-1] + low.iloc[-1] + close.iloc[-1]) / 3                        r1 = 2 * pivot - low.iloc[-1]            s1 = 2 * pivot - high.iloc[-1]            r2 = pivot + (high.iloc[-1] - low.iloc[-1])            s2 = pivot - (high.iloc[-1] - low.iloc[-1])                        current_price = close.iloc[-1]                        return {                'support': s1 if abs(current_price - s1) < abs(current_price - s2) else s2,                'resistance': r1 if abs(current_price - r1) < abs(current_price - r2) else r2,                'pivot': pivot            }                    except Exception:            return {'support': 0, 'resistance': 0, 'pivot': 0}class MarketConditionsAnalyzer:    """Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„ Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""        def __init__(self):        self.conditions_cache = {}        self.last_analysis = 0        def analyze_conditions(self) -> Dict[str, Any]:        """ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ Ù„Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚"""        current_time = time.time()        if current_time - self.last_analysis < 300:  # ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚            return self.conditions_cache                try:            conditions = {                'volatility_regime': self._get_volatility_regime(),                'volume_regime': self._get_volume_regime(),                'correlation_regime': self._get_correlation_regime(),                'sentiment_score': self._get_sentiment_score(),                'session_type': self._get_session_type()            }                        self.conditions_cache = conditions            self.last_analysis = current_time                        return conditions                    except Exception as e:            logger.error(f"âŒ [Market Conditions] Ø®Ø·Ø£: {e}")            return self._get_default_conditions()        def _get_volatility_regime(self) -> str:        """ØªØ­Ø¯ÙŠØ¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚Ù„Ø¨"""        try:            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 7)            if btc_data is None:                return "normal"                        returns = btc_data['close'].pct_change()            volatility = returns.rolling(24).std().iloc[-1] * np.sqrt(24) * 100                        if volatility < 2:                return "low"            elif volatility < 5:                return "normal"            elif volatility < 10:                return "high"            else:                return "extreme"                        except Exception:            return "normal"        def _get_volume_regime(self) -> str:        """ØªØ­Ù„ÙŠÙ„ Ù†Ø¸Ø§Ù… Ø­Ø¬Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„"""        try:            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 7)            if btc_data is None:                return "normal"                        volume = btc_data['volume']            avg_volume = volume.rolling(24).mean().iloc[-1]            current_volume = volume.iloc[-1]                        ratio = current_volume / avg_volume if avg_volume > 0 else 1                        if ratio < 0.7:                return "low"            elif ratio < 1.3:                return "normal"            elif ratio < 2:                return "high"            else:                return "spike"                        except Exception:            return "normal"        def _get_correlation_regime(self) -> str:        """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„Ø§Øª"""        try:            major_coins = ['ETHUSDT', 'ADAUSDT', 'SOLUSDT', 'DOTUSDT']            correlations = []                        btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 2)            if btc_data is None:                return "normal"                        btc_returns = btc_data['close'].pct_change().dropna()                        for coin in major_coins:                data = fetch_historical_data(coin, '1h', 2)                if data is not None:                    coin_returns = data['close'].pct_change().dropna()                    if len(coin_returns) > 0:                        corr = btc_returns.tail(10).corr(coin_returns.tail(10))                        correlations.append(abs(corr))                        avg_correlation = np.mean(correlations) if correlations else 0.5                        if avg_correlation < 0.3:                return "low"            elif avg_correlation < 0.7:                return "normal"            else:                return "high"                        except Exception:            return "normal"        def _get_sentiment_score(self) -> float:        """Ø­Ø³Ø§Ø¨ Ù…Ø¹Ù†ÙˆÙŠØ§Øª Ø§Ù„Ø³ÙˆÙ‚"""        try:            fear_greed = get_fear_and_greed_index()            if fear_greed['value'] != -1:                return (fear_greed['value'] - 50) / 50            return 0                    except Exception:            return 0        def _get_session_type(self) -> str:        """ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¬Ù„Ø³Ø©"""        active_sessions, liquidity_state, _ = get_session_state()        return liquidity_state        def _get_default_conditions(self) -> Dict[str, Any]:        """Ø§Ù„Ø¸Ø±ÙˆÙ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£"""        return {            'volatility_regime': 'normal',            'volume_regime': 'normal',            'correlation_regime': 'normal',            'sentiment_score': 0,            'session_type': 'NORMAL_LIQUIDITY'        }class EnhancedFilterSystem:    """Ù†Ø¸Ø§Ù… ÙÙ„Ø§ØªØ± Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ ØªÙƒÙŠÙ Ø°ÙƒÙŠ"""        def __init__(self):        self.analyzer = MarketConditionsAnalyzer()        def generate_filters(self) -> Dict[str, Any]:        """ØªÙˆÙ„ÙŠØ¯ ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙØ©"""        conditions = self.analyzer.analyze_conditions()                # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ        base_profile = FILTER_PROFILES["UPTREND"]["filters"].copy()                # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø¸Ø±ÙˆÙ                # 1. ØªØ¹Ø¯ÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„ØªÙ‚Ù„Ø¨        if conditions['volatility_regime'] == "low":            base_profile['min_volatility_pct'] *= 0.7            base_profile['min_rrr'] *= 1.2        elif conditions['volatility_regime'] == "high":            base_profile['min_volatility_pct'] *= 1.3            base_profile['min_rrr'] *= 0.8        elif conditions['volatility_regime'] == "extreme":            base_profile['min_volatility_pct'] *= 1.5            base_profile['min_rrr'] *= 0.6                # 2. ØªØ¹Ø¯ÙŠÙ„ Ø­Ø³Ø¨ Ø­Ø¬Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„        if conditions['volume_regime'] == "low":            base_profile['rel_vol'] *= 0.5        elif conditions['volume_regime'] == "high":            base_profile['rel_vol'] *= 1.2        elif conditions['volume_regime'] == "spike":            base_profile['rel_vol'] *= 1.5                # 3. ØªØ¹Ø¯ÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·        if conditions['correlation_regime'] == "high":            base_profile['min_btc_correlation'] = max(0.7, base_profile['min_btc_correlation'])        elif conditions['correlation_regime'] == "low":            base_profile['min_btc_correlation'] = max(0.2, base_profile['min_btc_correlation'])                # 4. ØªØ¹Ø¯ÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø¹Ù†ÙˆÙŠØ§Øª        sentiment = conditions['sentiment_score']        if sentiment > 0.5:            base_profile['rsi_range'] = (55, 85)            base_profile['roc'] = max(0.05, base_profile['roc'])        elif sentiment < -0.5:            base_profile['rsi_range'] = (35, 65)            base_profile['roc'] = max(-0.1, base_profile['roc'])                # 5. ØªØ¹Ø¯ÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„Ø¬Ù„Ø³Ø©        session_mult = {            "HIGH_LIQUIDITY": {"adx_mult": 1.05, "rel_vol_mult": 1.05, "rrr_mult": 0.95},            "NORMAL_LIQUIDITY": {"adx_mult": 1.0, "rel_vol_mult": 1.0, "rrr_mult": 1.0},            "LOW_LIQUIDITY": {"adx_mult": 0.95, "rel_vol_mult": 0.95, "rrr_mult": 1.05},            "WEEKEND": {"adx_mult": 0.9, "rel_vol_mult": 0.8, "rrr_mult": 1.1}        }                mult = session_mult.get(conditions['session_type'], session_mult["NORMAL_LIQUIDITY"])        base_profile['adx'] *= mult['adx_mult']        base_profile['rel_vol'] *= mult['rel_vol_mult']        base_profile['min_rrr'] *= mult['rrr_mult']                return {            "name": f"ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙØ© - {conditions['volatility_regime']}/{conditions['volume_regime']}",            "description": f"Ù†Ø¸Ø§Ù… Ù…ØªÙƒÙŠÙ: ØªÙ‚Ù„Ø¨={conditions['volatility_regime']}, Ø­Ø¬Ù…={conditions['volume_regime']}, Ø§Ø±ØªØ¨Ø§Ø·={conditions['correlation_regime']}",            "strategy": "MOMENTUM",            "filters": base_profile,            "conditions": conditions        }# ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©ENHANCED_FILTER_PROFILES = {    "STRONG_UPTREND": {        "description": "Ø§ØªØ¬Ø§Ù‡ ØµØ§Ø¹Ø¯ Ù‚ÙˆÙŠ Ù…Ø­Ø³Ù†",        "strategy": "MOMENTUM",        "filters": {            "adx": 35.0, "rel_vol": 0.8, "rsi_range": (60, 90), "roc": 0.15,            "slope": 0.02, "min_rrr": 1.3, "min_volatility_pct": 0.50,            "min_btc_correlation": 0.6, "min_bid_ask_ratio": 1.3        }    },    "UPTREND": {        "description": "Ø§ØªØ¬Ø§Ù‡ ØµØ§Ø¹Ø¯ Ù…Ø­Ø³Ù†",        "strategy": "MOMENTUM",        "filters": {            "adx": 25.0, "rel_vol": 0.4, "rsi_range": (52, 88), "roc": 0.05,            "slope": 0.01, "min_rrr": 1.4, "min_volatility_pct": 0.35,            "min_btc_correlation": 0.4, "min_bid_ask_ratio": 1.15        }    },    "RANGING": {        "description": "Ø§ØªØ¬Ø§Ù‡ Ø¹Ø±Ø¶ÙŠ Ù…Ø­Ø³Ù†",        "strategy": "MOMENTUM",        "filters": {            "adx": 20.0, "rel_vol": 0.3, "rsi_range": (45, 75), "roc": 0.03,            "slope": 0.0, "min_rrr": 1.6, "min_volatility_pct": 0.30,            "min_btc_correlation": 0.1, "min_bid_ask_ratio": 1.25        }    },    "DOWNTREND": {        "description": "Ø§ØªØ¬Ø§Ù‡ Ù‡Ø§Ø¨Ø· Ù…Ø­Ø³Ù† (Ø§Ù†Ø¹ÙƒØ§Ø³)",        "strategy": "REVERSAL",        "filters": {            "min_rrr": 2.2, "min_volatility_pct": 0.6, "min_btc_correlation": -0.3,            "min_relative_volume": 2.0, "min_bid_ask_ratio": 1.6        }    }}# ---------------------- Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© (Ù…Ø­ÙÙˆØ¸Ø©) ----------------------is_trading_enabled: bool = Falsetrading_status_lock = Lock()force_momentum_strategy: bool = Falseforce_momentum_lock = Lock()RISK_PER_TRADE_PERCENT: float = 1.0BASE_ML_MODEL_NAME: str = 'LightGBM_Scalping_V8_With_Momentum'MODEL_FOLDER: str = 'V8'SIGNAL_GENERATION_TIMEFRAME: str = '15m'TIMEFRAMES_FOR_TREND_LIGHTS: List[str] = ['15m', '1h', '4h']SIGNAL_GENERATION_LOOKBACK_DAYS: int = 30REDIS_PRICES_HASH_NAME: str = "crypto_bot_current_prices_v8"DIRECT_API_CHECK_INTERVAL: int = 10TRADING_FEE_PERCENT: float = 0.1STATS_TRADE_SIZE_USDT: float = 10.0BTC_SYMBOL: str = 'BTCUSDT'SYMBOL_PROCESSING_BATCH_SIZE: int = 50# ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙŠÙ…ADX_PERIOD: int = 14; RSI_PERIOD: int = 14; ATR_PERIOD: int = 14EMA_FAST_PERIOD: int = 50; EMA_SLOW_PERIOD: int = 200REL_VOL_PERIOD: int = 30; MOMENTUM_PERIOD: int = 12; EMA_SLOPE_PERIOD: int = 5MAX_OPEN_TRADES: int = 4BUY_CONFIDENCE_THRESHOLD = 0.80MIN_CONFIDENCE_INCREASE_FOR_UPDATE = 0.05ATR_FALLBACK_SL_MULTIPLIER: float = 1.5ATR_FALLBACK_TP_MULTIPLIER: float = 2.2USE_TRAILING_STOP_LOSS: bool = TrueTRAILING_ACTIVATION_PROFIT_PERCENT: float = 1.0TRAILING_DISTANCE_PERCENT: float = 0.8LAST_PEAK_UPDATE_TIME: Dict[int, float] = {}PEAK_UPDATE_COOLDOWN: int = 60USE_PEAK_FILTER: bool = TruePEAK_CHECK_PERIOD: int = 50PULLBACK_THRESHOLD_PCT: float = 0.988BREAKOUT_ALLOWANCE_PCT: float = 1.003DYNAMIC_FILTER_ANALYSIS_INTERVAL: int = 300  # ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚ORDER_BOOK_DEPTH_LIMIT: int = 100ORDER_BOOK_WALL_MULTIPLIER: float = 10.0ORDER_BOOK_ANALYSIS_RANGE_PCT: float = 0.02# ---------------------- Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ© (Ù…Ø­ÙÙˆØ¸Ø©) ----------------------conn: Optional[psycopg2.extensions.connection] = Noneclient: Optional[Client] = Noneredis_client: Optional[redis.Redis] = Noneml_models_cache: Dict[str, Any] = {}exchange_info_map: Dict[str, Any] = {}validated_symbols_to_scan: List[str] = []open_signals_cache: Dict[str, Dict] = {}signal_cache_lock = Lock()notifications_cache = deque(maxlen=50)notifications_lock = Lock()signals_pending_closure: Set[int] = set()closure_lock = Lock()last_api_check_time = time.time()rejection_logs_cache = deque(maxlen=100)rejection_logs_lock = Lock()last_market_state_check = 0current_market_state: Dict[str, Any] = {"overall_regime": "INITIALIZING", "trend_details_by_tf": {}, "last_updated": None}market_state_lock = Lock()dynamic_filter_profile_cache: Dict[str, Any] = {}last_dynamic_filter_analysis_time: float = 0dynamic_filter_lock = Lock()REJECTION_REASONS_AR = {    "Filters Not Loaded": "Ø§Ù„ÙÙ„Ø§ØªØ± ØºÙŠØ± Ù…Ø­Ù…Ù„Ø©",    "Low Volatility": "ØªÙ‚Ù„Ø¨ Ù…Ù†Ø®ÙØ¶ Ø¬Ø¯Ø§Ù‹",    "BTC Correlation": "Ø§Ø±ØªØ¨Ø§Ø· Ø¶Ø¹ÙŠÙ Ø¨Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†",    "RRR Filter": "Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©/Ø§Ù„Ø¹Ø§Ø¦Ø¯ ØºÙŠØ± ÙƒØ§ÙÙŠØ©",    "Reversal Volume Filter": "ÙÙˆÙ„ÙŠÙˆÙ… Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³ Ø¶Ø¹ÙŠÙ",    "Momentum/Strength Filter": "ÙÙ„ØªØ± Ø§Ù„Ø²Ø®Ù… ÙˆØ§Ù„Ù‚ÙˆØ©",    "Peak/Pullback Filter": "ÙÙ„ØªØ± Ø§Ù„Ù‚Ù…Ø©/Ø§Ù„ØªØµØ­ÙŠØ­",    "Invalid ATR for TP/SL": "ATR ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù",    "Reversal Signal Rejected by ML Model": "Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ Ø±ÙØ¶ Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³",    "Invalid Position Size": "Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© ØºÙŠØ± ØµØ§Ù„Ø­ (Ø§Ù„ÙˆÙ‚Ù ØªØ­Øª Ø§Ù„Ø¯Ø®ÙˆÙ„)",    "Lot Size Adjustment Failed": "ÙØ´Ù„ Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„Ø¹Ù‚Ø¯ (LOT_SIZE)",    "Min Notional Filter": "Ù‚ÙŠÙ…Ø© Ø§Ù„ØµÙÙ‚Ø© Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰",    "Insufficient Balance": "Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ",    "Order Book Fetch Failed": "ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª",    "Order Book Imbalance": "Ø§Ø®ØªÙ„Ø§Ù„ ØªÙˆØ§Ø²Ù† Ø¯ÙØªØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª (Ø¶ØºØ· Ø¨ÙŠØ¹)",    "Large Sell Wall Detected": "ØªÙ… ÙƒØ´Ù Ø¬Ø¯Ø§Ø± Ø¨ÙŠØ¹ Ø¶Ø®Ù…",}# ---------------------- Ø¯Ø§Ù„Ø© HTML Ø§Ù„Ù…Ø­Ø³Ù†Ø© (Ù…Ø­ÙÙˆØ¸Ø©) ----------------------def get_dashboard_html():    return """<!DOCTYPE html><html lang="ar" dir="rtl"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„ØªØ¯Ø§ÙˆÙ„ V28</title>    <script src="https://cdn.tailwindcss.com"></script>    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>    <link rel="preconnect" href="https://fonts.googleapis.com">    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700;800&display=swap" rel="stylesheet">    <style>        :root {            --bg-main: #0D1117; --bg-card: #161B22; --border-color: #30363D;            --text-primary: #E6EDF3; --text-secondary: #848D97;            --accent-blue: #58A6FF; --accent-green: #3FB950; --accent-red: #F85149; --accent-yellow: #D29922;        }        body { font-family: 'Tajawal', sans-serif; background-color: var(--bg-main); color: var(--text-primary); }        .card { background-color: var(--bg-card); border: 1px solid var(--border-color); border-radius: 0.5rem; transition: all 0.3s ease; }        .card:hover { border-color: var(--accent-blue); }        .skeleton { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; background-color: #21262d; border-radius: 0.5rem; }        @keyframes pulse { 50% { opacity: .6; } }        .progress-bar-container { position: relative; width: 100%; height: 0.75rem; background-color: #30363d; border-radius: 999px; overflow: hidden; }        .progress-bar { height: 100%; transition: width 0.5s ease-in-out; border-radius: 999px; }        .progress-labels { display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-secondary); padding: 0 2px; margin-top: 4px; }        #needle { transition: transform 1s cubic-bezier(0.68, -0.55, 0.27, 1.55); }        .tab-btn { position: relative; transition: color 0.2s ease; }        .tab-btn.active { color: var(--text-primary); }        .tab-btn.active::after { content: ''; position: absolute; bottom: -1px; left: 0; right: 0; height: 2px; background-color: var(--accent-blue); border-radius: 2px; }        .table-row:hover { background-color: #1a2029; }        .toggle-bg:after { content: ''; position: absolute; top: 2px; left: 2px; background: white; border-radius: 9999px; height: 1.25rem; width: 1.25rem; transition: transform 0.2s ease-in-out; }        input:checked + .toggle-bg:after { transform: translateX(100%); }        input:checked + .toggle-bg { background-color: var(--accent-green); }        .trend-light {            width: 1rem; height: 1rem; border-radius: 9999px;            border: 2px solid rgba(255, 255, 255, 0.1);            transition: background-color 0.5s ease, box-shadow 0.5s ease;            box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);        }        .light-on-green { background-color: var(--accent-green); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3), 0 0 10px 2px rgba(63, 185, 80, 0.6); }        .light-on-red { background-color: var(--accent-red); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3), 0 0 10px 2px rgba(248, 81, 73, 0.6); }        .light-on-yellow { background-color: var(--accent-yellow); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3), 0 0 10px 2px rgba(210, 153, 34, 0.6); }        .light-off { background-color: #303D; }    </style></head><body class="p-4 md:p-6">    <div class="container mx-auto max-w-screen-2xl">        <header class="mb-6 flex flex-wrap justify-between items-center gap-4">            <h1 class="text-2xl md:text-3xl font-extrabold text-white">                <span class="text-accent-blue">Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„ØªØ¯Ø§ÙˆÙ„</span>                <span class="text-text-secondary font-medium">V28</span>                <span class="text-xs text-green-400 ml-2">âœ¨ Ù…Ø­Ø³Ù†</span>            </h1>            <div id="trend-lights-container" class="flex items-center gap-x-6 bg-black/20 px-4 py-2 rounded-lg border border-border-color">                <div class="flex items-center gap-2" title="Ø§ØªØ¬Ø§Ù‡ ÙØ±ÙŠÙ… 15 Ø¯Ù‚ÙŠÙ‚Ø©"><div id="trend-light-15m" class="trend-light skeleton"></div><span class="text-sm font-bold text-text-secondary">15Ø¯</span></div>                <div class="flex items-center gap-2" title="Ø§ØªØ¬Ø§Ù‡ ÙØ±ÙŠÙ… Ø³Ø§Ø¹Ø©"><div id="trend-light-1h" class="trend-light skeleton"></div><span class="text-sm font-bold text-text-secondary">1Ø³</span></div>                <div class="flex items-center gap-2" title="Ø§ØªØ¬Ø§Ù‡ ÙØ±ÙŠÙ… 4 Ø³Ø§Ø¹Ø§Øª"><div id="trend-light-4h" class="trend-light skeleton"></div><span class="text-sm font-bold text-text-secondary">4Ø³</span></div>            </div>            <div id="connection-status" class="flex items-center gap-3 text-sm">                <div class="flex items-center gap-2"><div id="db-status-light" class="w-2.5 h-2.5 rounded-full bg-gray-600 animate-pulse"></div><span class="text-text-secondary">DB</span></div>                <div class="flex items-center gap-2"><div id="api-status-light" class="w-2.5 h-2.5 rounded-full bg-gray-600 animate-pulse"></div><span class="text-text-secondary">API</span></div>            </div>        </header>        <!-- Ù‚Ø³Ù… Ø§Ù„ØªØ­ÙƒÙ… ÙˆØ§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª -->        <section class="mb-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-5">            <div class="card p-4">                 <h3 class="font-bold mb-3 text-lg text-text-secondary">Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚ (BTC)</h3>                 <div class="grid grid-cols-2 gap-4 text-center">                     <div><h4 class="text-sm font-medium text-text-secondary">Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù… (4H)</h4><div id="overall-regime" class="text-2xl font-bold skeleton h-8 w-3/4 mx-auto mt-1"></div></div>                     <div><h4 class="text-sm font-medium text-text-secondary">Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©</h4><div id="active-strategy" class="text-xl font-bold skeleton h-7 w-2/3 mx-auto mt-1"></div></div>                 </div>                 <div id="market-conditions" class="mt-3 text-xs text-text-secondary">                     <div>ØªÙ‚Ù„Ø¨: <span id="vol-regime" class="text-accent-blue">Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„...</span></div>                     <div>Ø­Ø¬Ù…: <span id="vol-regime" class="text-accent-blue">Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„...</span></div>                 </div>            </div>            <div class="card p-4">                 <h3 class="font-bold mb-3 text-lg text-text-secondary">Ù…Ù„Ù Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ</h3>                 <div class="text-center">                     <div id="filter-profile-name" class="text-xl font-bold skeleton h-8 w-full mx-auto mt-1"></div>                     <div id="filter-profile-desc" class="text-sm text-text-secondary skeleton h-5 w-full mx-auto mt-2"></div>                 </div>            </div>            <div class="card p-4">                 <h3 class="font-bold mb-3 text-lg text-text-secondary">Ø§Ù„Ø¨ÙˆØ±ØµØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©</h3>                 <div id="active-sessions-list" class="flex flex-wrap gap-2 items-center justify-center pt-2 skeleton h-12 w-full"></div>            </div>            <div class="card p-4 flex flex-col justify-center items-center">                <h3 class="font-bold text-lg text-text-secondary mb-2">Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ</h3>                <div class="flex items-center space-x-3 space-x-reverse">                    <span id="trading-status-text" class="font-bold text-lg text-accent-red">ØºÙŠØ± Ù…ÙÙØ¹ÙÙ‘Ù„</span>                    <label for="trading-toggle" class="flex items-center cursor-pointer">                        <div class="relative"><input type="checkbox" id="trading-toggle" class="sr-only" onchange="toggleTrading()"><div class="toggle-bg block bg-accent-red w-12 h-7 rounded-full"></div></div>                    </label>                </div>                 <div class="mt-2 text-xs text-text-secondary">Ø±ØµÙŠØ¯ USDT: <span id="usdt-balance" class="font-mono skeleton w-20 inline-block"></span></div>            </div>            <div class="card p-4 flex flex-col justify-center items-center bg-blue-900/20 border-accent-blue">                <h3 class="font-bold text-lg text-text-secondary mb-2">Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©</h3>                <div class="flex items-center space-x-3 space-x-reverse">                    <span id="force-momentum-text" class="font-bold text-lg text-text-secondary">ØªÙ„Ù‚Ø§Ø¦ÙŠ</span>                    <label for="force-momentum-toggle" class="flex items-center cursor-pointer">                        <div class="relative"><input type="checkbox" id="force-momentum-toggle" class="sr-only" onchange="toggleMomentumStrategy()"><div class="toggle-bg block bg-gray-600 w-12 h-7 rounded-full"></div></div>                    </label>                </div>                 <div id="force-momentum-desc" class="mt-2 text-xs text-text-secondary text-center">ÙØ±Ø¶ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø²Ø®Ù…</div>            </div>        </section>        <section class="mb-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-5">            <div class="card p-4 flex flex-col justify-center items-center text-center">                <h3 class="font-bold text-text-secondary text-lg">ØµÙÙ‚Ø§Øª Ù…ÙØªÙˆØ­Ø©</h3>                <div id="open-trades-value" class="text-5xl font-black text-accent-blue mt-2 skeleton h-12 w-1/2"></div>            </div>            <div class="card p-4 flex flex-col justify-center items-center">                 <h3 class="font-bold mb-2 text-lg text-text-secondary">Ø§Ù„Ø®ÙˆÙ ÙˆØ§Ù„Ø·Ù…Ø¹</h3>                 <div id="fear-greed-gauge" class="relative w-full max-w-[150px] aspect-square"></div>                 <div id="fear-greed-value" class="text-3xl font-bold mt-[-20px] skeleton h-10 w-1/2"></div>                 <div id="fear-greed-text" class="text-md text-text-secondary skeleton h-6 w-3/4 mt-1"></div>            </div>            <div id="profit-chart-card" class="card lg:col-span-2 p-4">                <div class="flex justify-between items-center mb-3">                    <h3 class="font-bold text-lg text-text-secondary">Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠ (%)</h3>                    <div id="net-profit-usdt" class="text-2xl font-bold skeleton h-8 w-1/3"></div>                </div>                <div class="relative h-80">                    <canvas id="profitChart"></canvas>                    <div id="profit-chart-loader" class="absolute inset-0 flex items-center justify-center bg-bg-card z-10"><div class="skeleton w-full h-full"></div></div>                </div>            </div>        </section>        <div class="mb-4 border-b border-border-color">            <nav class="flex space-x-6 -mb-px" aria-label="Tabs">                <button onclick="showTab('signals', this)" class="tab-btn active text-white py-3 px-1 font-semibold">Ø§Ù„ØµÙÙ‚Ø§Øª</button>                <button onclick="showTab('stats', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</button>                <button onclick="showTab('notifications', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª</button>                <button onclick="showTab('rejections', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©</button>                <button onclick="showTab('filters', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ©</button>            </nav>        </div>        <main>            <div id="signals-tab" class="tab-content"><div class="overflow-x-auto card p-0"><table class="min-w-full text-sm text-right"><thead class="border-b border-border-color bg-black/20"><tr><th class="p-4 font-semibold text-text-secondary">Ø§Ù„Ø¹Ù…Ù„Ø©</th><th class="p-4 font-semibold text-text-secondary">Ø§Ù„Ø­Ø§Ù„Ø©</th><th class="p-4 font-semibold text-text-secondary">Ø§Ù„ÙƒÙ…ÙŠØ©</th><th class="p-4 font-semibold text-text-secondary">Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø©</th><th class="p-4 font-semibold text-text-secondary w-[25%]">Ø§Ù„ØªÙ‚Ø¯Ù…</th><th class="p-4 font-semibold text-text-secondary">Ø§Ù„Ø¯Ø®ÙˆÙ„/Ø§Ù„Ø­Ø§Ù„ÙŠ</th><th class="p-4 font-semibold text-text-secondary">Ø¥Ø¬Ø±Ø§Ø¡</th></tr></thead><tbody id="signals-table"></tbody></table></div></div>            <div id="stats-tab" class="tab-content hidden"><div id="stats-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div></div>            <div id="notifications-tab" class="tab-content hidden"><div id="notifications-list" class="card p-4 max-h-[60vh] overflow-y-auto space-y-2"></div></div>            <div id="rejections-tab" class="tab-content hidden"><div id="rejections-list" class="card p-4 max-h-[60vh] overflow-y-auto space-y-2"></div></div>            <div id="filters-tab" class="tab-content hidden"><div id="filters-display" class="card p-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div></div>        </main>    </div><script>// ... (Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø­ÙÙˆØ¸ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…) ...</script></body></html>    """# ---------------------- Ø¯ÙˆØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ù…Ø­ÙÙˆØ¸Ø©) ----------------------def init_db(retries: int = 5, delay: int = 5) -> None:    global conn    logger.info("[DB] Initializing database connection...")    db_url_to_use = DB_URL    if 'postgres' in db_url_to_use and 'sslmode' not in db_url_to_use:        separator = '&' if '?' in db_url_to_use else '?'        db_url_to_use += f"{separator}sslmode=require"        for attempt in range(retries):        try:            conn = psycopg2.connect(db_url_to_use, connect_timeout=15, cursor_factory=RealDictCursor)            conn.autocommit = False                        with conn.cursor() as cur:                cur.execute("""                    CREATE TABLE IF NOT EXISTS signals (                        id SERIAL PRIMARY KEY, symbol TEXT NOT NULL, entry_price DOUBLE PRECISION NOT NULL,                        target_price DOUBLE PRECISION NOT NULL, stop_loss DOUBLE PRECISION NOT NULL,                        status TEXT DEFAULT 'open', closing_price DOUBLE PRECISION, closed_at TIMESTAMP,                        profit_percentage DOUBLE PRECISION, strategy_name TEXT, signal_details JSONB,                        current_peak_price DOUBLE PRECISION, is_real_trade BOOLEAN DEFAULT FALSE,                        quantity DOUBLE PRECISION, order_id TEXT                    );                """)                cur.execute("CREATE INDEX IF NOT EXISTS idx_signals_status ON signals (status);")                cur.execute("""                    CREATE TABLE IF NOT EXISTS notifications (                        id SERIAL PRIMARY KEY, timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                        type TEXT NOT NULL, message TEXT NOT NULL, is_read BOOLEAN DEFAULT FALSE                    );                """)            conn.commit()            logger.info("âœ… [DB] Database connection and schema are up-to-date.")            return        except Exception as e:            logger.error(f"âŒ [DB] Error during initialization (Attempt {attempt + 1}/{retries}): {e}")            if conn: conn.rollback()            if attempt < retries - 1: time.sleep(delay)            else: logger.critical("âŒ [DB] Failed to connect to the database.")# ... (Ø¨Ø§Ù‚ÙŠ Ø¯ÙˆØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ø­ÙÙˆØ¸Ø©) ...# ---------------------- Ø¯ÙˆØ§Ù„ Binance ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ù…Ø­ÙÙˆØ¸Ø©) ----------------------def get_exchange_info_map() -> None:    global exchange_info_map    if not client: return    logger.info("â„¹ï¸ [Exchange Info] Fetching exchange trading rules...")    try:        info = client.get_exchange_info()        exchange_info_map = {s['symbol']: s for s in info['symbols']}        logger.info(f"âœ… [Exchange Info] Loaded rules for {len(exchange_info_map)} symbols.")    except Exception as e:        logger.error(f"âŒ [Exchange Info] Could not fetch exchange info: {e}")def get_validated_symbols(filename: str = 'crypto_list.txt') -> List[str]:    """Ù…Ø­ÙÙˆØ¸Ø© ØªÙ…Ø§Ù…Ø§Ù‹ ÙƒÙ…Ø§ ÙƒØ§Ù†Øª"""    if not client: return []    try:        script_dir = os.path.dirname(os.path.abspath(__file__))        file_path = os.path.join(script_dir, filename)        with open(file_path, 'r', encoding='utf-8') as f:            raw_symbols = {line.strip().upper() for line in f if line.strip() and not line.startswith('#')}        formatted = {f"{s}USDT" if not s.endswith('USDT') else s for s in raw_symbols}                if not exchange_info_map: get_exchange_info_map()        active = {s for s, info in exchange_info_map.items() if info.get('quoteAsset') == 'USDT' and info.get('status') == 'TRADING'}        validated = sorted(list(formatted.intersection(active)))        logger.info(f"âœ… [Validation] Bot will monitor {len(validated)} symbols.")        return validated    except Exception as e:        logger.error(f"âŒ [Validation] Error during symbol validation: {e}", exc_info=True)        return []# ... (Ø¨Ø§Ù‚ÙŠ Ø¯ÙˆØ§Ù„ Binance Ù…Ø­ÙÙˆØ¸Ø©) ...# ---------------------- Ø¯ÙˆØ§Ù„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© ÙˆØ§Ù„ØªØ¯Ø§ÙˆÙ„ (Ù…Ø­ÙÙˆØ¸Ø© Ù…Ø¹ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª) ----------------------class EnhancedTradingStrategy:    def __init__(self, symbol: str):        self.symbol = symbol        model_bundle = load_ml_model_bundle_from_folder(symbol)        self.ml_model, self.scaler, self.feature_names = (model_bundle.get('model'), model_bundle.get('scaler'), model_bundle.get('feature_names')) if model_bundle else (None, None, None)    def get_features(self, df_15m: pd.DataFrame, df_4h: pd.DataFrame, btc_df: pd.DataFrame) -> Optional[pd.DataFrame]:        if self.feature_names is None: return None        try:            df_featured = calculate_features(df_15m, btc_df)            df_4h_features = calculate_features(df_4h, None)            df_4h_features = df_4h_features.rename(columns=lambda c: f"{c}_4h", inplace=False)            required_4h_cols = ['rsi_4h', 'price_vs_ema50_4h']            df_featured = df_featured.join(df_4h_features[required_4h_cols], how='outer')            df_featured.fillna(method='ffill', inplace=True)            for col in self.feature_names:                if col not in df_featured.columns: df_featured[col] = 0.0            df_featured.replace([np.inf, -np.inf], np.nan, inplace=True)            return df_featured.dropna(subset=self.feature_names)        except Exception as e:            logger.error(f"âŒ [{self.symbol}] Feature engineering failed: {e}", exc_info=True)            return None    def generate_buy_signal(self, df_features: pd.DataFrame) -> Optional[Dict[str, Any]]:        if not all([self.ml_model, self.scaler, self.feature_names]) or df_features.empty: return None        try:            last_row_ordered_df = df_features.iloc[[-1]][self.feature_names]            features_scaled_np = self.scaler.transform(last_row_ordered_df)            features_scaled_df = pd.DataFrame(features_scaled_np, columns=self.feature_names)            prediction = self.ml_model.predict(features_scaled_df)[0]            if prediction != 1: return None                        prediction_proba = self.ml_model.predict_proba(features_scaled_df)            confidence = float(np.max(prediction_proba[0]))            logger.debug(f"â„¹ï¸ [{self.symbol}] ML Model predicted 'BUY' with {confidence:.2%} confidence.")            return {'prediction': int(prediction), 'confidence': confidence}        except Exception as e:            logger.warning(f"âš ï¸ [{self.symbol}] ML Signal Generation Error: {e}")            return None# ... (Ø¨Ø§Ù‚ÙŠ Ø¯ÙˆØ§Ù„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© ÙˆØ§Ù„ØªØ¯Ø§ÙˆÙ„ Ù…Ø­ÙÙˆØ¸Ø©) ...# ---------------------- Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (Ø§Ù„Ù…Ø­Ø¯Ø«Ø©) ----------------------def determine_market_state_enhanced():    """Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ù† ØªØ­Ø¯ÙŠØ¯ Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚"""    global current_market_state, last_market_state_check        with market_state_lock:        if time.time() - last_market_state_check < 180:  # ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 3 Ø¯Ù‚Ø§Ø¦Ù‚            return        logger.info("ğŸ§  [Enhanced Market State] ØªØ­Ø¯ÙŠØ« Ø´Ø§Ù…Ù„ Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚...")        try:        trend_details = {}        btc_data = get_btc_data_for_bot()                for tf in TIMEFRAMES_FOR_TREND_LIGHTS:            days_to_fetch = 3 if tf == '15m' else (5 if tf == '1h' else 20)            df = fetch_historical_data(BTC_SYMBOL, tf, days_to_fetch)                        if df is not None and btc_data is not None:                trend_details[tf] = EnhancedTrendAnalyzer.get_enhanced_trend(df, BTC_SYMBOL, btc_data)            else:                trend_details[tf] = {"trend": "Uncertain", "strength": 0, "confidence": 0}                        time.sleep(0.1)                # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù…        trends = [trend_details[tf]['trend'] for tf in TIMEFRAMES_FOR_TREND_LIGHTS]        trend_counts = {}        for trend in trends:            trend_counts[trend] = trend_counts.get(trend, 0) + 1                overall_regime = max(trend_counts, key=trend_counts.get)        overall_regime_key = overall_regime.upper().replace(" ", "_")                # Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù‚ÙˆØ©        avg_strength = np.mean([trend_details[tf]['strength'] for tf in TIMEFRAMES_FOR_TREND_LIGHTS])                with market_state_lock:            current_market_state = {                "overall_regime": overall_regime_key,                "trend_details_by_tf": trend_details,                "overall_strength": float(avg_strength),                "last_updated": datetime.now(timezone.utc).isoformat()            }            last_market_state_check = time.time()                    logger.info(f"âœ… [Enhanced Market State] {overall_regime} (Ù‚ÙˆØ©: {avg_strength:.2f})")            except Exception as e:        logger.error(f"âŒ [Enhanced Market State] Ø®Ø·Ø£: {e}", exc_info=True)        with market_state_lock:            current_market_state['overall_regime'] = "RANGING"            current_market_state['trend_details_by_tf'] = {}# ---------------------- Ù†Ø¸Ø§Ù… Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù† ----------------------enhanced_filter_system = EnhancedFilterSystem()def analyze_market_and_create_dynamic_profile_enhanced():    """Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ù† ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚"""    global dynamic_filter_profile_cache, last_dynamic_filter_analysis_time        with dynamic_filter_lock:        if time.time() - last_dynamic_filter_analysis_time < DYNAMIC_FILTER_ANALYSIS_INTERVAL:            return        logger.info("ğŸ”¬ [Enhanced Filter] ØªØ­Ù„ÙŠÙ„ Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚ ÙˆØªÙˆÙ„ÙŠØ¯ ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙØ©...")        with force_momentum_lock:        is_forced = force_momentum_strategy        if is_forced:        logger.warning("âš ï¸ [OVERRIDE] Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø²Ø®Ù… Ù…ÙØ±ÙˆØ¶Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹")        base_profile = ENHANCED_FILTER_PROFILES["UPTREND"].copy()        description = "Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø²Ø®Ù… Ù…ÙØ±ÙˆØ¶Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹"    else:        enhanced_profile = enhanced_filter_system.generate_filters()        description = enhanced_profile['description']        base_profile = enhanced_profile['filters']        with dynamic_filter_lock:        dynamic_filter_profile_cache = {            "name": description,            "description": description,            "strategy": "MOMENTUM" if not is_forced else "MOMENTUM",            "filters": base_profile,            "last_updated": datetime.now(timezone.utc).isoformat(),        }        last_dynamic_filter_analysis_time = time.time()        logger.info(f"âœ… [Enhanced Filter] ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙÙ„Ø§ØªØ± Ù…ØªÙƒÙŠÙØ© Ø¬Ø¯ÙŠØ¯Ø©")# ---------------------- ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© ØªØ·Ø¨ÙŠÙ‚Ø§Øª Flask (Ù…Ø­ÙÙˆØ¸Ø©) ----------------------app = Flask(__name__)CORS(app)# ... (Ø¨Ø§Ù‚ÙŠ Ø¯ÙˆØ§Ù„ Flask Ù…Ø­ÙÙˆØ¸Ø© ØªÙ…Ø§Ù…Ø§Ù‹) ...# ---------------------- Ù†Ù‚Ø·Ø© Ø§Ù†Ø·Ù„Ø§Ù‚ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ (Ø§Ù„Ù…Ø­Ø¯Ø«Ø©) ----------------------def run_websocket_manager():    """Ù…Ø­ÙÙˆØ¸Ø© ØªÙ…Ø§Ù…Ø§Ù‹"""    if not client or not validated_symbols_to_scan:        logger.error("âŒ [WebSocket] Cannot start: Client or symbols not initialized.")        return    logger.info("ğŸ“¡ [WebSocket] Starting WebSocket Manager...")    twm = ThreadedWebsocketManager(api_key=API_KEY, api_secret=API_SECRET)    twm.start()    streams = [f"{s.lower()}@miniTicker" for s in validated_symbols_to_scan]    twm.start_multiplex_socket(callback=handle_price_update_message, streams=streams)    logger.info(f"âœ… [WebSocket] Subscribed to {len(streams)} price streams.")    twm.join()def initialize_bot_services():    """Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ù† Ø¨Ø¯Ø¡ Ø§Ù„Ø®Ø¯Ù…Ø§Øª"""    global client, validated_symbols_to_scan    logger.info("ğŸ¤– [Bot Services] Starting enhanced background initialization...")    try:        client = Client(API_KEY, API_SECRET)        init_db()        init_redis()        get_exchange_info_map()        load_open_signals_to_cache()        load_notifications_to_cache()                validated_symbols_to_scan = get_validated_symbols()        if not validated_symbols_to_scan:            logger.critical("âŒ No validated symbols to scan. Bot will not start."); return                # Ø¨Ø¯Ø¡ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©        Thread(target=determine_market_state_enhanced, daemon=True).start()        Thread(target=run_websocket_manager, daemon=True).start()        Thread(target=trade_monitoring_loop, daemon=True).start()        Thread(target=main_loop_enhanced, daemon=True).start()        logger.info("âœ… [Bot Services] All enhanced background services started successfully.")    except Exception as e:        log_and_notify("critical", f"A critical error occurred during initialization: {e}", "SYSTEM")        exit(1)# ---------------------- Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© ----------------------def main_loop_enhanced():    """Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©"""    logger.info("[Enhanced Main Loop] Waiting for initialization...")    time.sleep(15)    if not validated_symbols_to_scan:        log_and_notify("critical", "No validated symbols to scan. Bot will not start.", "SYSTEM")        return    log_and_notify("info", f"âœ… Starting enhanced main scan loop for {len(validated_symbols_to_scan)} symbols.", "SYSTEM")    while True:        try:            logger.info("ğŸ”„ Starting new enhanced cycle...")            ml_models_cache.clear(); gc.collect()            determine_market_state_enhanced()            analyze_market_and_create_dynamic_profile_enhanced()                        filter_profile = get_current_filter_profile()            active_strategy_type = filter_profile.get("strategy")                        if not active_strategy_type or active_strategy_type == "DISABLED":                logger.warning(f"ğŸ›‘ Trading is disabled by enhanced profile. Skipping cycle.")                time.sleep(300)                continue            btc_data = get_btc_data_for_bot()                        symbols_with_models = []            script_dir = os.path.dirname(os.path.abspath(__file__))            model_dir_path = os.path.join(script_dir, MODEL_FOLDER)            for symbol in validated_symbols_to_scan:                if os.path.exists(os.path.join(model_dir_path, f"{BASE_ML_MODEL_NAME}_{symbol}.pkl")):                    symbols_with_models.append(symbol)                        if not symbols_with_models:                logger.warning("âš ï¸ No symbols with models found. Skipping scan cycle.")                time.sleep(300)                continue                            logger.info(f"âœ… Found {len(symbols_with_models)} symbols with models. Active Strategy: {active_strategy_type}")            symbols_to_process = random.sample(symbols_with_models, len(symbols_with_models))                        processed_count = 0            for symbol in symbols_to_process:                strategy, df_15m, df_4h, df_features = None, None, None, None                try:                    with signal_cache_lock:                        if symbol in open_signals_cache or len(open_signals_cache) >= MAX_OPEN_TRADES:                            continue                                        df_15m = fetch_historical_data(symbol, SIGNAL_GENERATION_TIMEFRAME, SIGNAL_GENERATION_LOOKBACK_DAYS)                    if df_15m is None or df_15m.empty: continue                    df_15m.name = symbol                    df_features_with_indicators = calculate_features(df_15m, btc_data)                    if df_features_with_indicators is None or df_features_with_indicators.empty: continue                    df_features_with_indicators.name = symbol                                        technical_signal = None                    if active_strategy_type == "REVERSAL":                        technical_signal = find_crazy_reversal_signal(df_features_with_indicators)                    elif active_strategy_type == "MOMENTUM":                        technical_signal = {"signal_type": "MOMENTUM"}                    if not technical_signal:                        continue                                        strategy = EnhancedTradingStrategy(symbol)                    if not all([strategy.ml_model, strategy.scaler, strategy.feature_names]): continue                                        df_4h = fetch_historical_data(symbol, '4h', SIGNAL_GENERATION_LOOKBACK_DAYS)                    if df_4h is None or df_4h.empty: continue                                        df_features = strategy.get_features(df_15m, df_4h, btc_data)                    if df_features is None or df_features.empty: continue                                        ml_signal = strategy.generate_buy_signal(df_features)                                        if not ml_signal or ml_signal['confidence'] < BUY_CONFIDENCE_THRESHOLD:                        if "REVERSAL" in technical_signal['signal_type']:                            log_rejection(symbol, "Reversal Signal Rejected by ML Model", {"ML_confidence": ml_signal.get('confidence') if ml_signal else 'N/A'})                        continue                                        try:                        entry_price = float(client.get_symbol_ticker(symbol=symbol)['price'])                    except Exception as e:                        logger.error(f"âŒ [{symbol}] Could not fetch entry price: {e}. Skipping.")                        continue                    last_features = df_features.iloc[-1]                    last_atr = last_features.get('atr', 0)                    tp_sl_data = calculate_tp_sl(symbol, entry_price, last_atr)                                        if not tp_sl_data or not passes_filters(symbol, last_features, filter_profile, entry_price, tp_sl_data, df_15m):                        continue                    order_book_analysis = analyze_order_book(symbol, entry_price)                    if not order_book_analysis or not passes_order_book_check(symbol, order_book_analysis, filter_profile):                        continue                                        strategy_name_for_db = f"Reversal_ML_Enhanced" if active_strategy_type == "REVERSAL" else f"Momentum_ML_Enhanced"                    new_signal = {                        'symbol': symbol, 'strategy_name': strategy_name_for_db,                        'signal_details': {                            'ML_Confidence': ml_signal['confidence'],                            'ML_Confidence_Display': f"{ml_signal['confidence']:.2%}",                            'Filter_Profile': f"{filter_profile['name']}",                            'Technical_Reason': technical_signal.get('reason', 'N/A'),                            'Bid_Ask_Ratio': order_book_analysis.get('bid_ask_ratio', 0),                            'Trend_Strength': trend_details.get('15m', {}).get('strength', 0)                        },                        'entry_price': entry_price, **tp_sl_data                    }                                        with trading_status_lock: is_enabled = is_trading_enabled                    if is_enabled:                        quantity = calculate_position_size(symbol, entry_price, new_signal['stop_loss'])                        if quantity and quantity > 0:                            order_result = place_order(symbol, Client.SIDE_BUY, quantity)                            if order_result:                                new_signal.update({'is_real_trade': True, 'quantity': float(quantity), 'order_id': order_result['orderId']})                            else: continue                        else: continue                    else:                        new_signal['is_real_trade'] = False                    saved_signal = insert_signal_into_db(new_signal)                    if saved_signal:                        with signal_cache_lock: open_signals_cache[saved_signal['symbol']] = saved_signal                        send_new_signal_alert(saved_signal)                except Exception as e:                    logger.error(f"âŒ [Enhanced Processing Error] for symbol {symbol}: {e}", exc_info=True)                finally:                    del strategy, df_15m, df_4h, df_features                    processed_count += 1                    if processed_count % SYMBOL_PROCESSING_BATCH_SIZE == 0:                        logger.info("ğŸ“¦ Processed batch. Running memory cleanup...")                        ml_models_cache.clear(); gc.collect()                        time.sleep(2)                                        time.sleep(0.75)  # ØªØ£Ø®ÙŠØ± Ù„Ù„Ø­Ø¯ Ù…Ù† API rate limits                        logger.info("âœ… [Enhanced End of Cycle] Full scan cycle finished.")            perform_end_of_cycle_cleanup()            logger.info(f"â³ [Enhanced End of Cycle] Waiting for 60 seconds...")            time.sleep(60)        except (KeyboardInterrupt, SystemExit):            log_and_notify("info", "Bot is shutting down by user request.", "SYSTEM"); break        except Exception as main_err:            log_and_notify("error", f"Critical error in enhanced main loop: {main_err}", "SYSTEM"); time.sleep(120)# ---------------------- Ø¯Ø§Ù„Ø© ØªØ´ØºÙŠÙ„ Flask Ø§Ù„Ù…Ø¶Ø§ÙØ© ----------------------def run_flask():    """ØªÙ‚ÙˆÙ… Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø¨Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø®Ø§Ø¯Ù… Ø§Ù„ÙˆÙŠØ¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ù€ Flask."""    logger.info("ğŸŒ [Web Server] Starting Flask development server...")    try:        # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØºÙŠØ± Ø§Ù„Ø¨ÙŠØ¦Ø© PORT Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ù‹Ø§ØŒ ÙˆØ¥Ù„Ø§ Ø§Ø³ØªØ®Ø¯Ù… 5001        port = int(os.environ.get("PORT", 5001))        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø®Ø§Ø¯Ù… Ù„ÙŠÙƒÙˆÙ† Ù…ØªØ§Ø­Ù‹Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø¨ÙƒØ©        app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)    except Exception as e:        logger.critical(f"âŒ [Web Server] Failed to start Flask server: {e}", exc_info=True)        os._exit(1) # Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø®Ø§Ø¯Ù… ÙÙŠ Ø§Ù„Ø¨Ø¯Ø¡# ---------------------- Ù†Ù‚Ø·Ø© Ø§Ù†Ø·Ù„Ø§Ù‚ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ ----------------------if __name__ == "__main__":    logger.info("ğŸš€ LAUNCHING ENHANCED TRADING BOT & DASHBOARD (V28 - Enhanced Filters) ğŸš€")    initialization_thread = Thread(target=initialize_bot_services, daemon=True)    initialization_thread.start()    run_flask()    logger.info("ğŸ‘‹ [Shutdown] Application has been shut down."); os._exit(0)