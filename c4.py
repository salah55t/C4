# ملف c4_complete_v28_fixed.py - النسخة الكاملة والمصححة V28# تم مراجعته وتصحيحه بواسطة Geminiimport timeimport osimport jsonimport loggingimport requestsimport numpy as npimport pandas as pdimport psycopg2import pickleimport redisimport reimport gcimport randomfrom decimal import Decimal, ROUND_DOWNfrom urllib.parse import urlparsefrom psycopg2 import sql, OperationalError, InterfaceErrorfrom psycopg2.extras import RealDictCursorfrom binance.client import Clientfrom binance.exceptions import BinanceAPIExceptionfrom flask import Flask, jsonify, render_template_stringfrom flask_cors import CORSfrom threading import Thread, Lockfrom datetime import datetime, timezonefrom decouple import configfrom typing import List, Dict, Optional, Any, Set, Tuplefrom sklearn.preprocessing import StandardScalerfrom collections import dequeimport warnings# --- إعدادات التجاهل واللوجر ---warnings.simplefilter(action='ignore', category=FutureWarning)warnings.simplefilter(action='ignore', category=UserWarning)logging.basicConfig(    level=logging.INFO,    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',    handlers=[        logging.FileHandler('crypto_bot_v28_complete_logs.log', encoding='utf-8'),        logging.StreamHandler()    ])logger = logging.getLogger('CryptoBotV28_Complete')# --- تحميل متغيرات البيئة ---try:    API_KEY: str = config('BINANCE_API_KEY')    API_SECRET: str = config('BINANCE_API_SECRET')    DB_URL: str = config('DATABASE_URL')    REDIS_URL: str = config('REDIS_URL', default='redis://localhost:6379/0')except Exception as e:    logger.critical(f"❌ فشل حاسم في تحميل متغيرات البيئة الأساسية: {e}")    exit(1)# --- متغيرات عامة وإعدادات البوت ---is_trading_enabled: bool = Falsetrading_status_lock = Lock()force_momentum_strategy: bool = Falseforce_momentum_lock = Lock()RISK_PER_TRADE_PERCENT: float = 1.0BASE_ML_MODEL_NAME: str = 'LightGBM_Scalping_V8_With_Momentum'MODEL_FOLDER: str = 'V8'SIGNAL_GENERATION_TIMEFRAME: str = '15m'TIMEFRAMES_FOR_TREND_LIGHTS: List[str] = ['15m', '1h', '4h']SIGNAL_GENERATION_LOOKBACK_DAYS: int = 30REDIS_PRICES_HASH_NAME: str = "crypto_bot_current_prices_v8"TRADING_FEE_PERCENT: float = 0.1STATS_TRADE_SIZE_USDT: float = 10.0BTC_SYMBOL: str = 'BTCUSDT'SYMBOL_PROCESSING_BATCH_SIZE: int = 50MAX_OPEN_TRADES: int = 4BUY_CONFIDENCE_THRESHOLD = 0.80# --- إعدادات المؤشرات الفنية ---ADX_PERIOD: int = 14RSI_PERIOD: int = 14ATR_PERIOD: int = 14EMA_FAST_PERIOD: int = 50EMA_SLOW_PERIOD: int = 200REL_VOL_PERIOD: int = 30MOMENTUM_PERIOD: int = 12EMA_SLOPE_PERIOD: int = 5# --- إعدادات الفلاتر المتقدمة ---USE_TRAILING_STOP_LOSS: bool = TrueTRAILING_ACTIVATION_PROFIT_PERCENT: float = 1.0TRAILING_DISTANCE_PERCENT: float = 0.8USE_PEAK_FILTER: bool = TruePEAK_CHECK_PERIOD: int = 50PULLBACK_THRESHOLD_PCT: float = 0.988BREAKOUT_ALLOWANCE_PCT: float = 1.003DYNAMIC_FILTER_ANALYSIS_INTERVAL: int = 300ORDER_BOOK_DEPTH_LIMIT: int = 100ORDER_BOOK_WALL_MULTIPLIER: float = 10.0ORDER_BOOK_ANALYSIS_RANGE_PCT: float = 0.02# --- متغيرات الحالة والكاش ---conn: Optional[psycopg2.extensions.connection] = Noneclient: Optional[Client] = Noneredis_client: Optional[redis.Redis] = Noneml_models_cache: Dict[str, Any] = {}exchange_info_map: Dict[str, Any] = {}validated_symbols_to_scan: List[str] = []open_signals_cache: Dict[str, Dict] = {}signal_cache_lock = Lock()notifications_cache = deque(maxlen=50)notifications_lock = Lock()rejection_logs_cache = deque(maxlen=100)rejection_logs_lock = Lock()current_market_state: Dict[str, Any] = {"overall_regime": "INITIALIZING", "trend_details_by_tf": {}, "last_updated": None}market_state_lock = Lock()dynamic_filter_profile_cache: Dict[str, Any] = {}last_dynamic_filter_analysis_time: float = 0dynamic_filter_lock = Lock()last_market_state_check = 0# --- قاموس أسباب الرفض باللغة العربية ---REJECTION_REASONS_AR = {    "Filters Not Loaded": "الفلاتر غير محملة",    "Low Volatility": "تقلب منخفض جداً",    "BTC Correlation": "ارتباط ضعيف بالبيتكوين",    "RRR Filter": "نسبة المخاطرة/العائد غير كافية",    "Reversal Volume Filter": "فوليوم الانعكاس ضعيف",    "Momentum/Strength Filter": "فلتر الزخم والقوة",    "Peak/Pullback Filter": "فلتر القمة/التصحيح",    "Invalid ATR for TP/SL": "ATR غير صالح لحساب الأهداف",    "Reversal Signal Rejected by ML Model": "نموذج التعلم الآلي رفض إشارة الانعكاس",    "Invalid Position Size": "حجم الصفقة غير صالح (الوقف تحت الدخول)",    "Lot Size Adjustment Failed": "فشل ضبط حجم العقد (LOT_SIZE)",    "Min Notional Filter": "قيمة الصفقة أقل من الحد الأدنى",    "Insufficient Balance": "الرصيد غير كافٍ",    "Order Book Fetch Failed": "فشل جلب دفتر الطلبات",    "Order Book Imbalance": "اختلال توازن دفتر الطلبات (ضغط بيع)",    "Large Sell Wall Detected": "تم كشف جدار بيع ضخم",}# --- دوال تهيئة الخدمات ---def init_db(retries: int = 5, delay: int = 5) -> None:    """تهيئة الاتصال بقاعدة البيانات وإنشاء الجداول إذا لم تكن موجودة."""    global conn    logger.info("[DB] تهيئة الاتصال بقاعدة البيانات...")    db_url_to_use = DB_URL    if 'postgres' in db_url_to_use and 'sslmode' not in db_url_to_use:        separator = '&' if '?' in db_url_to_use else '?'        db_url_to_use += f"{separator}sslmode=require"        for attempt in range(retries):        try:            conn = psycopg2.connect(db_url_to_use, connect_timeout=15, cursor_factory=RealDictCursor)            conn.autocommit = False                        with conn.cursor() as cur:                cur.execute("""                    CREATE TABLE IF NOT EXISTS signals (                        id SERIAL PRIMARY KEY, symbol TEXT NOT NULL, entry_price DOUBLE PRECISION NOT NULL,                        target_price DOUBLE PRECISION NOT NULL, stop_loss DOUBLE PRECISION NOT NULL,                        status TEXT DEFAULT 'open', closing_price DOUBLE PRECISION, closed_at TIMESTAMP,                        profit_percentage DOUBLE PRECISION, strategy_name TEXT, signal_details JSONB,                        current_peak_price DOUBLE PRECISION, is_real_trade BOOLEAN DEFAULT FALSE,                        quantity DOUBLE PRECISION, order_id TEXT                    );                """)                cur.execute("CREATE INDEX IF NOT EXISTS idx_signals_status ON signals (status);")                cur.execute("""                    CREATE TABLE IF NOT EXISTS notifications (                        id SERIAL PRIMARY KEY, timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                        type TEXT NOT NULL, message TEXT NOT NULL, is_read BOOLEAN DEFAULT FALSE                    );                """)            conn.commit()            logger.info("✅ [DB] الاتصال بقاعدة البيانات وتحديث المخطط بنجاح.")            return        except Exception as e:            logger.error(f"❌ [DB] خطأ أثناء التهيئة (محاولة {attempt + 1}/{retries}): {e}")            if conn: conn.rollback()            if attempt < retries - 1: time.sleep(delay)            else: logger.critical("❌ [DB] فشل الاتصال بقاعدة البيانات.")def check_db_connection() -> bool:    """التحقق من حالة الاتصال بقاعدة البيانات وإعادة الاتصال عند الحاجة."""    global conn    if conn is None or conn.closed != 0:        logger.warning("[DB] الاتصال مغلق، محاولة إعادة الاتصال...")        init_db()    try:        if conn and conn.closed == 0:            with conn.cursor() as cur: cur.execute("SELECT 1;")            return True        return False    except (OperationalError, InterfaceError) as e:        logger.error(f"❌ [DB] فقدان الاتصال: {e}. إعادة الاتصال...")        try:            init_db()            return conn is not None and conn.closed == 0        except Exception as retry_e:            logger.error(f"❌ [DB] فشل إعادة الاتصال: {retry_e}")            return Falsedef log_and_notify(level: str, message: str, notification_type: str):    """تسجيل رسالة وإرسال إشعار إلى قاعدة البيانات."""    log_methods = {'info': logger.info, 'warning': logger.warning, 'error': logger.error, 'critical': logger.critical}    log_methods.get(level.lower(), logger.info)(message)    if not check_db_connection() or not conn: return    try:        new_notification = {"timestamp": datetime.now(timezone.utc).isoformat(), "type": notification_type, "message": message}        with notifications_lock: notifications_cache.appendleft(new_notification)        with conn.cursor() as cur: cur.execute("INSERT INTO notifications (type, message) VALUES (%s, %s);", (notification_type, message))        conn.commit()    except Exception as e:        logger.error(f"❌ [Notify DB] فشل حفظ الإشعار: {e}")        if conn: conn.rollback()def log_rejection(symbol: str, reason_key: str, details: Optional[Dict] = None):    """تسجيل سبب رفض صفقة معينة."""    reason_ar = REJECTION_REASONS_AR.get(reason_key, reason_key)    log_message = f"🚫 [REJECTED] {symbol} | Reason: {reason_key} | Details: {details or {}}"    logger.info(log_message)    with rejection_logs_lock:        rejection_logs_cache.appendleft({            "timestamp": datetime.now(timezone.utc).isoformat(),            "symbol": symbol,            "reason": reason_ar,            "details": details or {}        })def init_redis() -> None:    """تهيئة الاتصال بخادم Redis."""    global redis_client    logger.info("[Redis] تهيئة الاتصال بـ Redis...")    try:        redis_client = redis.from_url(REDIS_URL, decode_responses=True)        redis_client.ping()        logger.info("✅ [Redis] تم الاتصال بنجاح بخادم Redis.")    except redis.exceptions.ConnectionError as e:        logger.critical(f"❌ [Redis] فشل الاتصال بـ Redis: {e}")        exit(1)def get_exchange_info_map() -> None:    """جلب معلومات وقواعد التداول من منصة باينانس."""    global exchange_info_map    if not client: return    logger.info("ℹ️ [Exchange Info] جلب قواعد التداول من المنصة...")    try:        info = client.get_exchange_info()        exchange_info_map = {s['symbol']: s for s in info['symbols']}        logger.info(f"✅ [Exchange Info] تم تحميل القواعد لـ {len(exchange_info_map)} عملة.")    except Exception as e:        logger.error(f"❌ [Exchange Info] لم يتمكن من جلب معلومات المنصة: {e}")def get_validated_symbols(filename: str = 'crypto_list.txt') -> List[str]:    """قراءة قائمة العملات من ملف والتحقق من صلاحيتها للتداول."""    if not client: return []    try:        script_dir = os.path.dirname(os.path.abspath(__file__))        file_path = os.path.join(script_dir, filename)        if not os.path.exists(file_path):            logger.warning(f"⚠️ ملف العملات '{filename}' غير موجود. سيتم استخدام قائمة افتراضية.")            # يمكنك وضع قائمة افتراضية هنا إذا أردت            raw_symbols = {'BTC', 'ETH', 'BNB', 'SOL', 'XRP'}        else:            with open(file_path, 'r', encoding='utf-8') as f:                raw_symbols = {line.strip().upper() for line in f if line.strip() and not line.startswith('#')}                formatted = {f"{s}USDT" if not s.endswith('USDT') else s for s in raw_symbols}                if not exchange_info_map: get_exchange_info_map()        active = {s for s, info in exchange_info_map.items() if info.get('quoteAsset') == 'USDT' and info.get('status') == 'TRADING'}        validated = sorted(list(formatted.intersection(active)))        logger.info(f"✅ [Validation] سيقوم البوت بمراقبة {len(validated)} عملة.")        return validated    except Exception as e:        logger.error(f"❌ [Validation] خطأ أثناء التحقق من العملات: {e}", exc_info=True)        return []def fetch_historical_data(symbol: str, interval: str, days: int) -> Optional[pd.DataFrame]:    """جلب البيانات التاريخية لعملة معينة."""    if not client: return None    try:        # حساب عدد الشموع المطلوبة        minutes_in_interval = int(re.sub('[a-zA-Z]', '', interval))        if 'h' in interval: minutes_in_interval *= 60        if 'd' in interval: minutes_in_interval *= 1440        limit = int((days * 24 * 60) / minutes_in_interval)                klines = client.get_historical_klines(symbol, interval, limit=min(limit, 1000))        if not klines: return None                df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'quote_volume', 'trades', 'taker_buy_base', 'taker_buy_quote', 'ignore'])        df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]        for col in ['open', 'high', 'low', 'close', 'volume']:            df[col] = pd.to_numeric(df[col], errors='coerce')                df = df.astype({'open': np.float32, 'high': np.float32, 'low': np.float32, 'close': np.float32, 'volume': np.float32})        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)        df.set_index('timestamp', inplace=True)        return df.dropna()    except BinanceAPIException as e:        logger.error(f"❌ [Data] خطأ من Binance API لـ {symbol}: {e}")        if e.code == -1003:            logger.critical("تم حظر الـ IP! الانتظار لمدة 60 ثانية.")            time.sleep(60)        return None    except Exception as e:        logger.error(f"❌ [Data] خطأ في جلب البيانات التاريخية لـ {symbol}: {e}")        return Nonedef analyze_order_book(symbol: str, entry_price: float) -> Optional[Dict[str, Any]]:    """تحليل دفتر الطلبات (Order Book) لتقييم ضغط البيع والشراء."""    if not client: return None    try:        order_book = client.get_order_book(symbol=symbol, limit=ORDER_BOOK_DEPTH_LIMIT)                bids = pd.DataFrame(order_book['bids'], columns=['price', 'qty'], dtype=float)        asks = pd.DataFrame(order_book['asks'], columns=['price', 'qty'], dtype=float)        price_range = entry_price * ORDER_BOOK_ANALYSIS_RANGE_PCT        relevant_bids_vol = bids[bids['price'] >= entry_price - price_range]['qty'].sum()        relevant_asks_vol = asks[asks['price'] <= entry_price + price_range]['qty'].sum()        bid_ask_ratio = relevant_bids_vol / relevant_asks_vol if relevant_asks_vol > 0 else float('inf')        # تصحيح: تم إزالة السطر المكرر هنا        avg_ask_qty = asks['qty'].mean()        sell_wall_threshold = avg_ask_qty * ORDER_BOOK_WALL_MULTIPLIER        nearby_asks = asks[asks['price'].between(entry_price, entry_price * 1.05)]        large_sell_walls = nearby_asks[nearby_asks['qty'] > sell_wall_threshold]        analysis_result = {            "bid_ask_ratio": bid_ask_ratio,            "has_large_sell_wall": not large_sell_walls.empty,            "wall_details": large_sell_walls.to_dict('records') if not large_sell_walls.empty else []        }        logger.info(f"📖 [{symbol}] تحليل دفتر الطلبات: النسبة={bid_ask_ratio:.2f}, وجود جدار بيع={analysis_result['has_large_sell_wall']}")        return analysis_result    except Exception as e:        logger.error(f"❌ [{symbol}] فشل في جلب أو تحليل دفتر الطلبات: {e}")        log_rejection(symbol, "Order Book Fetch Failed", {"error": str(e)})        return Nonedef calculate_features(df: pd.DataFrame, btc_df: Optional[pd.DataFrame]) -> pd.DataFrame:    """حساب المؤشرات الفنية والميزات المطلوبة لنموذج التعلم الآلي."""    df_calc = df.copy()        # ATR    high_low = df_calc['high'] - df_calc['low']    high_close = (df_calc['high'] - df_calc['close'].shift()).abs()    low_close = (df_calc['low'] - df_calc['close'].shift()).abs()    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)    df_calc['atr'] = tr.ewm(span=ATR_PERIOD, adjust=False).mean()        # ADX    up_move = df_calc['high'].diff()    down_move = -df_calc['low'].diff()    plus_dm = pd.Series(np.where((up_move > down_move) & (up_move > 0), up_move, 0.0), index=df_calc.index)    minus_dm = pd.Series(np.where((down_move > up_move) & (down_move > 0), down_move, 0.0), index=df_calc.index)    plus_di = 100 * plus_dm.ewm(span=ADX_PERIOD, adjust=False).mean() / df_calc['atr'].replace(0, 1e-9)    minus_di = 100 * minus_dm.ewm(span=ADX_PERIOD, adjust=False).mean() / df_calc['atr'].replace(0, 1e-9)    dx = 100 * (abs(plus_di - minus_di) / (plus_di + minus_di).replace(0, 1e-9))    df_calc['adx'] = dx.ewm(span=ADX_PERIOD, adjust=False).mean()        # RSI    delta = df_calc['close'].diff()    gain = delta.clip(lower=0).ewm(com=RSI_PERIOD - 1, adjust=False).mean()    loss = -delta.clip(upper=0).ewm(com=RSI_PERIOD - 1, adjust=False).mean()    df_calc['rsi'] = 100 - (100 / (1 + (gain / loss.replace(0, 1e-9))))        # مقاييس الفوليوم والسعر    df_calc['relative_volume'] = df_calc['volume'] / (df_calc['volume'].rolling(window=REL_VOL_PERIOD, min_periods=1).mean() + 1e-9)    df_calc['price_vs_ema50'] = (df_calc['close'] / df_calc['close'].ewm(span=EMA_FAST_PERIOD, adjust=False).mean()) - 1    df_calc['price_vs_ema200'] = (df_calc['close'] / df_calc['close'].ewm(span=EMA_SLOW_PERIOD, adjust=False).mean()) - 1        # الارتباط بالبيتكوين    if btc_df is not None and not btc_df.empty:        merged_df = pd.merge(df_calc, btc_df[['btc_returns']], left_index=True, right_index=True, how='left').fillna(0)        df_calc['btc_correlation'] = df_calc['close'].pct_change().rolling(window=30).corr(merged_df['btc_returns'])    else:        df_calc['btc_correlation'] = 0.0            # ROC و ميل EMA    df_calc[f'roc_{MOMENTUM_PERIOD}'] = (df_calc['close'] / df_calc['close'].shift(MOMENTUM_PERIOD) - 1) * 100    ema_slope = df_calc['close'].ewm(span=EMA_SLOPE_PERIOD, adjust=False).mean()    df_calc[f'ema_slope_{EMA_SLOPE_PERIOD}'] = (ema_slope - ema_slope.shift(1)) / ema_slope.shift(1).replace(0, 1e-9) * 100        return df_calc.astype('float32', errors='ignore')def get_session_state() -> Tuple[List[str], str, str]:    """تحديد جلسات التداول النشطة وحالة السيولة."""    sessions = {"London": (8, 17), "New York": (13, 22), "Tokyo": (0, 9)}    active_sessions = []    now_utc = datetime.now(timezone.utc)    current_hour = now_utc.hour    if now_utc.weekday() >= 5: # السبت والأحد        return [], "WEEKEND", "سيولة منخفضة جدا (عطلة نهاية الأسبوع)"    for session, (start, end) in sessions.items():        if start <= current_hour < end:            active_sessions.append(session)    if "London" in active_sessions and "New York" in active_sessions:        return active_sessions, "HIGH_LIQUIDITY", "سيولة عالية (تداخل لندن/نيويورك)"    elif len(active_sessions) >= 1:        return active_sessions, "NORMAL_LIQUIDITY", f"سيولة عادية ({', '.join(active_sessions)})"    else:        return [], "LOW_LIQUIDITY", "سيولة منخفضة (خارج أوقات الذروة)"def get_btc_data_for_bot() -> Optional[pd.DataFrame]:    """جلب بيانات البيتكوين لاستخدامها في التحليلات."""    btc_data = fetch_historical_data(BTC_SYMBOL, SIGNAL_GENERATION_TIMEFRAME, SIGNAL_GENERATION_LOOKBACK_DAYS)    if btc_data is not None:        btc_data['btc_returns'] = btc_data['close'].pct_change()    return btc_datadef load_open_signals_to_cache():    """تحميل الصفقات المفتوحة من قاعدة البيانات إلى الكاش عند بدء التشغيل."""    if not check_db_connection() or not conn: return    try:        with conn.cursor() as cur:            cur.execute("SELECT * FROM signals WHERE status IN ('open', 'updated');")            open_signals = cur.fetchall()            with signal_cache_lock:                open_signals_cache.clear()                # تصحيح: تم إصلاح الحلقة لتعبئة الكاش بشكل صحيح                for signal in open_signals:                     open_signals_cache[signal['symbol']] = dict(signal)            logger.info(f"✅ [Loading] تم تحميل {len(open_signals)} صفقة مفتوحة.")    except Exception as e:        logger.error(f"❌ [Loading] فشل تحميل الصفقات المفتوحة: {e}")def load_notifications_to_cache():    """تحميل آخر الإشعارات من قاعدة البيانات إلى الكاش."""    if not check_db_connection() or not conn: return    try:        with conn.cursor() as cur:            cur.execute("SELECT * FROM notifications ORDER BY timestamp DESC LIMIT 50;")            recent = cur.fetchall()            with notifications_lock:                notifications_cache.clear()                for n in reversed(recent):                    n['timestamp'] = n['timestamp'].isoformat()                    notifications_cache.appendleft(dict(n))            logger.info(f"✅ [Loading] تم تحميل {len(notifications_cache)} إشعار.")    except Exception as e:        logger.error(f"❌ [Loading] فشل تحميل الإشعارات: {e}")# ---------------------- أنظمة التحليل المتقدمة ----------------------class MarketConditionsAnalyzer:    """فئة لتحليل ظروف السوق العامة (تقلب، فوليوم، ارتباط)."""    def __init__(self):        self.conditions_cache = {}        self.last_analysis = 0        def analyze_conditions(self) -> Dict[str, Any]:        """إجراء تحليل شامل لظروف السوق."""        current_time = time.time()        if current_time - self.last_analysis < 300: # تحديث كل 5 دقائق            return self.conditions_cache                try:            conditions = {                'volatility_regime': self._get_volatility_regime(),                'volume_regime': self._get_volume_regime(),                'correlation_regime': self._get_correlation_regime(),                'session_type': self._get_session_type()            }                        self.conditions_cache = conditions            self.last_analysis = current_time            return conditions                    except Exception as e:            logger.error(f"❌ [Market Conditions] خطأ: {e}")            return self._get_default_conditions()        def _get_volatility_regime(self) -> str:        """تحديد نظام التقلب بناءً على ATR للبيتكوين."""        try:            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 7)            if btc_data is None: return "normal"                        returns = btc_data['close'].pct_change()            # حساب التقلب السنوي بالساعة            volatility = returns.rolling(24).std().iloc[-1] * np.sqrt(24 * 365) * 100                        if volatility < 20: return "low"            elif volatility < 60: return "normal"            else: return "high"        except: return "normal"        def _get_volume_regime(self) -> str:        """تحديد نظام الفوليوم."""        try:            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 7)            if btc_data is None: return "normal"                        volume = btc_data['volume']            # تصحيح: تم إصلاح السطر المكسور هنا            avg_volume = volume.rolling(24).mean().iloc[-1]            current_volume = volume.iloc[-1]            ratio = current_volume / avg_volume if avg_volume > 0 else 1                        if ratio < 0.7: return "low"            elif ratio < 1.5: return "normal"            else: return "high"        except: return "normal"        def _get_correlation_regime(self) -> str:        """تحديد نظام الارتباط بين العملات الرئيسية والبيتكوين."""        try:            major_coins = ['ETHUSDT', 'ADAUSDT', 'SOLUSDT', 'DOTUSDT']            correlations = []            btc_data = fetch_historical_data(BTC_SYMBOL, '1h', 2)            if btc_data is None: return "normal"                        btc_returns = btc_data['close'].pct_change().dropna()            for coin in major_coins:                data = fetch_historical_data(coin, '1h', 2)                if data is not None:                    coin_returns = data['close'].pct_change().dropna()                    # التأكد من تطابق الأطوال                    common_index = btc_returns.index.intersection(coin_returns.index)                    if len(common_index) > 10:                        corr = btc_returns.loc[common_index].corr(coin_returns.loc[common_index])                        correlations.append(abs(corr))            avg_correlation = np.mean(correlations) if correlations else 0.5            if avg_correlation < 0.3: return "low"            elif avg_correlation < 0.7: return "normal"            else: return "high"        except: return "normal"    def _get_session_type(self) -> str:        """الحصول على حالة السيولة من الدالة العامة."""        _, liquidity_state, _ = get_session_state()        return liquidity_state        def _get_default_conditions(self) -> Dict[str, Any]:        """إرجاع قيم افتراضية في حال فشل التحليل."""        return {'volatility_regime': 'normal', 'volume_regime': 'normal', 'correlation_regime': 'normal', 'session_type': 'NORMAL_LIQUIDITY'}class EnhancedFilterSystem:    """نظام لتوليد فلاتر تداول ديناميكية بناءً على ظروف السوق."""    def __init__(self):        self.analyzer = MarketConditionsAnalyzer()        def generate_filters(self) -> Dict[str, Any]:        """توليد ملف فلاتر متكيف."""        conditions = self.analyzer.analyze_conditions()        base_profile = {            "adx": 25.0, "rel_vol": 0.4, "rsi_range": (52, 88), "roc": 0.05,            "slope": 0.01, "min_rrr": 1.4, "min_volatility_pct": 0.35,            "min_btc_correlation": 0.4, "min_bid_ask_ratio": 1.15        }                # تطبيق التعديلات حسب الظروف        if conditions['volatility_regime'] == "low":            base_profile['min_volatility_pct'] *= 0.7            base_profile['min_rrr'] *= 1.2        elif conditions['volatility_regime'] == "high":            base_profile['min_volatility_pct'] *= 1.3            base_profile['min_rrr'] *= 0.8                if conditions['volume_regime'] == "low":            base_profile['rel_vol'] *= 0.5        elif conditions['volume_regime'] == "high":            base_profile['rel_vol'] *= 1.2                if conditions['correlation_regime'] == "high":            base_profile['min_btc_correlation'] = max(0.7, base_profile['min_btc_correlation'])        elif conditions['correlation_regime'] == "low":            base_profile['min_btc_correlation'] = max(0.2, base_profile['min_btc_correlation'])                return {            "name": f"فلاتر متكيفة - {conditions['volatility_regime']}",            "description": f"نظام متكيف: {conditions['volatility_regime']}/{conditions['volume_regime']}",            "strategy": "MOMENTUM",            "filters": base_profile,            "conditions": conditions        }enhanced_filter_system = EnhancedFilterSystem()# ---------------------- استراتيجية التداول والفلاتر ----------------------class EnhancedTradingStrategy:    """فئة لتغليف منطق استراتيجية التداول باستخدام التعلم الآلي."""    def __init__(self, symbol: str):        self.symbol = symbol        model_bundle = self._load_ml_model(symbol)        self.ml_model, self.scaler, self.feature_names = (model_bundle.get('model'), model_bundle.get('scaler'), model_bundle.get('feature_names')) if model_bundle else (None, None, None)    def _load_ml_model(self, symbol: str) -> Optional[Dict[str, Any]]:        """تحميل نموذج التعلم الآلي من ملف."""        model_name = f"{BASE_ML_MODEL_NAME}_{symbol}"        if model_name in ml_models_cache:            return ml_models_cache[model_name]                script_dir = os.path.dirname(os.path.abspath(__file__))        model_dir_path = os.path.join(script_dir, MODEL_FOLDER)        model_path = os.path.join(model_dir_path, f"{model_name}.pkl")                if not os.path.exists(model_path):            return None                try:            with open(model_path, 'rb') as f:                model_bundle = pickle.load(f)            if 'model' in model_bundle and 'scaler' in model_bundle and 'feature_names' in model_bundle:                ml_models_cache[model_name] = model_bundle                return model_bundle            return None        except Exception as e:            logger.error(f"❌ [ML Model] خطأ في تحميل النموذج لـ {symbol}: {e}")            return None    def get_features(self, df_15m: pd.DataFrame, df_4h: pd.DataFrame, btc_df: pd.DataFrame) -> Optional[pd.DataFrame]:        """تجهيز الميزات للنموذج."""        if self.feature_names is None: return None        try:            df_featured = calculate_features(df_15m, btc_df)            df_4h_features = calculate_features(df_4h, None)            df_4h_features = df_4h_features.rename(columns=lambda c: f"{c}_4h", inplace=False)            required_4h_cols = ['rsi_4h', 'price_vs_ema50_4h']            df_featured = df_featured.join(df_4h_features[required_4h_cols], how='outer')            df_featured.fillna(method='ffill', inplace=True)            for col in self.feature_names:                if col not in df_featured.columns:                    df_featured[col] = 0.0            df_featured.replace([np.inf, -np.inf], np.nan, inplace=True)            return df_featured.dropna(subset=self.feature_names)        except Exception as e:            logger.error(f"❌ [{self.symbol}] فشل هندسة الميزات: {e}", exc_info=True)            return None    def generate_buy_signal(self, df_features: pd.DataFrame) -> Optional[Dict[str, Any]]:        """توليد إشارة شراء من النموذج."""        if not all([self.ml_model, self.scaler, self.feature_names]) or df_features.empty:            return None        try:            last_row_ordered_df = df_features.iloc[[-1]][self.feature_names]            features_scaled_np = self.scaler.transform(last_row_ordered_df)            features_scaled_df = pd.DataFrame(features_scaled_np, columns=self.feature_names)            prediction = self.ml_model.predict(features_scaled_df)[0]            if prediction != 1:                return None                        prediction_proba = self.ml_model.predict_proba(features_scaled_df)            confidence = float(np.max(prediction_proba[0]))            logger.debug(f"ℹ️ [{self.symbol}] تنبأ النموذج بـ 'شراء' بثقة {confidence:.2%}.")            return {'prediction': int(prediction), 'confidence': confidence}        except Exception as e:            logger.warning(f"⚠️ [{self.symbol}] خطأ في توليد إشارة النموذج: {e}")            return Nonedef passes_filters(symbol: str, last_features: pd.Series, profile: Dict[str, Any], entry_price: float, tp_sl_data: Dict, df_15m: pd.DataFrame) -> bool:    """التحقق مما إذا كانت الإشارة تمر عبر جميع الفلاتر الديناميكية."""    filters = profile.get("filters", {})    if not filters:        log_rejection(symbol, "Filters Not Loaded", {"profile": profile.get('name')})        return False        # التحقق من التقلب    volatility = (last_features.get('atr', 0) / entry_price * 100) if entry_price > 0 else 0    if volatility < filters.get('min_volatility_pct', 0.0):        log_rejection(symbol, "Low Volatility", {"volatility": f"{volatility:.2f}%", "min": f"{filters.get('min_volatility_pct', 0.0):.2f}%"})        return False    # التحقق من الارتباط بالبيتكوين    correlation = last_features.get('btc_correlation', 0)    if correlation < filters.get('min_btc_correlation', -1.0):        log_rejection(symbol, "BTC Correlation", {"corr": f"{correlation:.2f}", "min": f"{filters.get('min_btc_correlation', -1.0)}"})        return False    # التحقق من نسبة المخاطرة للعائد    risk = entry_price - float(tp_sl_data['stop_loss'])    reward = float(tp_sl_data['target_price']) - entry_price    if risk <= 0 or reward <= 0 or (reward / risk) < filters.get('min_rrr', 0.0):        log_rejection(symbol, "RRR Filter", {"rrr": f"{(reward/risk):.2f}" if risk > 0 else "N/A", "min": f"{filters.get('min_rrr', 0.0):.2f}"})        return False    # فلاتر الزخم    adx = last_features.get('adx', 0)    rel_vol = last_features.get('relative_volume', 0)    rsi = last_features.get('rsi', 0)    roc = last_features.get(f'roc_{MOMENTUM_PERIOD}', 0)    slope = last_features.get(f'ema_slope_{EMA_SLOPE_PERIOD}', 0)    rsi_min, rsi_max = filters.get('rsi_range', (0, 100))    if not (adx >= filters.get('adx', 0) and             rel_vol >= filters.get('rel_vol', 0) and             rsi_min <= rsi < rsi_max and            roc > filters.get('roc', -100) and            slope > filters.get('slope', -100)):        log_rejection(symbol, "Momentum/Strength Filter", {            "ADX": f"{adx:.2f}", "Volume": f"{rel_vol:.2f}", "RSI": f"{rsi:.2f}",            "ROC": f"{roc:.2f}", "Slope": f"{slope:.6f}"        })        return False        # فلتر القمة/التصحيح    if USE_PEAK_FILTER:        with market_state_lock:            market_regime = current_market_state.get("overall_regime", "RANGING")        if df_15m is not None and len(df_15m) >= PEAK_CHECK_PERIOD:            recent_candles = df_15m.iloc[-PEAK_CHECK_PERIOD:-1]            if not recent_candles.empty:                highest_high = recent_candles['high'].max()                is_strong_uptrend = (market_regime == "STRONG_UPTREND")                # السماح باختراق بسيط في الترند القوي، أو انتظار تصحيح في الترند العادي                price_limit = highest_high * (BREAKOUT_ALLOWANCE_PCT if is_strong_uptrend else PULLBACK_THRESHOLD_PCT)                if not (entry_price <= price_limit):                    log_rejection(symbol, "Peak/Pullback Filter", {"entry": f"{entry_price:.4f}", "limit": f"{price_limit:.4f}"})                    return False    return Truedef passes_order_book_check(symbol: str, order_book_analysis: Dict, profile: Dict) -> bool:    """التحقق من فلاتر دفتر الطلبات."""    filters = profile.get("filters", {})    min_ratio = filters.get('min_bid_ask_ratio', 1.0)        if order_book_analysis.get('has_large_sell_wall', True):        log_rejection(symbol, "Large Sell Wall Detected", {"details": order_book_analysis.get('wall_details')})        return False            bid_ask_ratio = order_book_analysis.get('bid_ask_ratio', 0)    if bid_ask_ratio < min_ratio:        log_rejection(symbol, "Order Book Imbalance", {"ratio": f"{bid_ask_ratio:.2f}", "min_required": min_ratio})        return False            return Truedef calculate_tp_sl(symbol: str, entry_price: float, last_atr: float) -> Optional[Dict[str, Any]]:    """حساب وقف الخسارة وجني الأرباح بناءً على ATR."""    if last_atr <= 0:        log_rejection(symbol, "Invalid ATR for TP/SL", {"atr": last_atr})        return None    # استخدام مضاعفات ATR افتراضية    tp = entry_price + (last_atr * 2.2)    sl = entry_price - (last_atr * 1.5)    return {'target_price': tp, 'stop_loss': sl, 'source': 'ATR_Fallback'}# ---------------------- دوال إدارة الصفقات ----------------------def adjust_quantity_to_lot_size(symbol: str, quantity: float) -> Optional[Decimal]:    """تعديل الكمية لتتوافق مع قاعدة LOT_SIZE للمنصة."""    try:        symbol_info = exchange_info_map.get(symbol)        if not symbol_info: return None        for f in symbol_info['filters']:            if f['filterType'] == 'LOT_SIZE':                step_size = Decimal(f['stepSize'])                return (Decimal(str(quantity)) // step_size) * step_size        return Decimal(str(quantity))    except Exception as e:        logger.error(f"[{symbol}] خطأ في تعديل الكمية حسب LOT_SIZE: {e}")        return Nonedef calculate_position_size(symbol: str, entry_price: float, stop_loss_price: float) -> Optional[Decimal]:    """حساب حجم الصفقة بناءً على إدارة المخاطر."""    if not client: return None    try:        balance_response = client.get_asset_balance(asset='USDT')        available_balance = Decimal(balance_response['free'])        risk_amount_usdt = available_balance * (Decimal(str(RISK_PER_TRADE_PERCENT)) / Decimal('100'))                risk_per_coin = Decimal(str(entry_price)) - Decimal(str(stop_loss_price))        if risk_per_coin <= 0:            log_rejection(symbol, "Invalid Position Size", {"detail": "وقف الخسارة يجب أن يكون تحت سعر الدخول."})            return None                    initial_quantity = risk_amount_usdt / risk_per_coin        adjusted_quantity = adjust_quantity_to_lot_size(symbol, float(initial_quantity))        if adjusted_quantity is None or adjusted_quantity <= 0:            log_rejection(symbol, "Lot Size Adjustment Failed", {"quantity": f"{adjusted_quantity}"})            return None        notional_value = adjusted_quantity * Decimal(str(entry_price))        symbol_info = exchange_info_map.get(symbol)        if symbol_info:            for f in symbol_info['filters']:                if f['filterType'] in ('MIN_NOTIONAL', 'NOTIONAL'):                    min_notional = Decimal(f.get('minNotional', f.get('notional', '0')))                    if notional_value < min_notional:                        log_rejection(symbol, "Min Notional Filter", {"value": f"{notional_value:.2f}", "required": f"{min_notional}"})                        return None                if notional_value > available_balance:            log_rejection(symbol, "Insufficient Balance", {"required": f"{notional_value:.2f}", "available": f"{available_balance:.2f}"})            return None        logger.info(f"✅ [{symbol}] تم حساب حجم الصفقة: {adjusted_quantity} | المخاطرة: ${risk_amount_usdt:.2f}")        return adjusted_quantity    except Exception as e:        logger.error(f"❌ [{symbol}] خطأ في حساب حجم الصفقة: {e}", exc_info=True)        return Nonedef place_order(symbol: str, side: str, quantity: Decimal, order_type: str = Client.ORDER_TYPE_MARKET) -> Optional[Dict]:    """تنفيذ أمر تداول حقيقي على المنصة."""    if not client: return None    logger.info(f"➡️ [{symbol}] محاولة تنفيذ أمر {side} حقيقي لكمية {quantity}.")    try:        order = client.create_order(symbol=symbol, side=side, type=order_type, quantity=float(quantity))        logger.info(f"✅ [{symbol}] تم تنفيذ أمر {side} حقيقي بنجاح! Order ID: {order['orderId']}")        log_and_notify('info', f"TRADE REAL: Placed {side} order for {quantity} {symbol}.", "REAL_TRADE")        return order    except Exception as e:        logger.error(f"❌ [{symbol}] خطأ من باينانس عند تنفيذ الأمر: {e}")        log_and_notify('error', f"REAL TRADE FAILED: {symbol} | {e}", "REAL_TRADE_ERROR")        return Nonedef insert_signal_into_db(signal_data: Dict) -> Optional[Dict]:    """إدراج إشارة جديدة في قاعدة البيانات."""    if not check_db_connection() or not conn: return None    try:        with conn.cursor() as cur:            cur.execute("""                INSERT INTO signals (symbol, entry_price, target_price, stop_loss, strategy_name, signal_details, is_real_trade, quantity, order_id)                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING *;            """, (                signal_data['symbol'], signal_data['entry_price'], signal_data['target_price'],                signal_data['stop_loss'], signal_data['strategy_name'], json.dumps(signal_data['signal_details']),                signal_data.get('is_real_trade', False), signal_data.get('quantity'), signal_data.get('order_id')            ))            saved_signal = cur.fetchone()            conn.commit()            logger.info(f"💾 [{signal_data['symbol']}] تم حفظ الإشارة الجديدة في قاعدة البيانات.")            return dict(saved_signal)    except Exception as e:        logger.error(f"❌ [DB Insert] فشل إدراج الإشارة: {e}")        if conn: conn.rollback()        return None# ---------------------- دوال النظام الرئيسية ----------------------def determine_market_state_enhanced():    """تحديد حالة السوق العامة بناءً على تحليل متعدد الأطر الزمنية للبيتكوين."""    global current_market_state, last_market_state_check        with market_state_lock:        if time.time() - last_market_state_check < 180: # تحديث كل 3 دقائق            return        logger.info("🧠 [Enhanced Market State] تحديث شامل لحالة السوق...")        try:        trend_details = {}        for tf in TIMEFRAMES_FOR_TREND_LIGHTS:            days_to_fetch = 3 if tf == '15m' else (5 if tf == '1h' else 20)            df = fetch_historical_data(BTC_SYMBOL, tf, days_to_fetch)                        if df is not None:                # حساب المؤشرات الأساسية للاتجاه                ema_fast = df['close'].ewm(span=12, adjust=False).mean().iloc[-1]                ema_slow = df['close'].ewm(span=26, adjust=False).mean().iloc[-1]                adx_df = calculate_features(df, None)                adx = adx_df['adx'].iloc[-1] if not adx_df.empty else 0                trend = "Uncertain"                if ema_fast > ema_slow and adx > 25: trend = "Strong Uptrend"                elif ema_fast > ema_slow: trend = "Uptrend"                elif ema_fast < ema_slow and adx > 25: trend = "Strong Downtrend"                elif ema_fast < ema_slow: trend = "Downtrend"                else: trend = "Ranging"                trend_details[tf] = {"trend": trend, "adx": float(adx)}            else:                trend_details[tf] = {"trend": "Uncertain", "adx": 0}            time.sleep(0.1)                trends = [details['trend'] for details in trend_details.values()]        trend_counts = {t: trends.count(t) for t in set(trends)}        overall_regime = max(trend_counts, key=trend_counts.get)                with market_state_lock:            current_market_state = {                "overall_regime": overall_regime.upper().replace(" ", "_"),                "trend_details_by_tf": trend_details,                "last_updated": datetime.now(timezone.utc).isoformat()            }            last_market_state_check = time.time()                    logger.info(f"✅ [Enhanced Market State] الحالة العامة: {overall_regime}")            except Exception as e:        logger.error(f"❌ [Enhanced Market State] خطأ: {e}", exc_info=True)        with market_state_lock:            current_market_state['overall_regime'] = "RANGING"def analyze_market_and_create_dynamic_profile_enhanced():    """تحليل السوق وتوليد ملف فلاتر ديناميكي."""    global dynamic_filter_profile_cache, last_dynamic_filter_analysis_time        with dynamic_filter_lock:        if time.time() - last_dynamic_filter_analysis_time < DYNAMIC_FILTER_ANALYSIS_INTERVAL:            return        logger.info("🔬 [Enhanced Filter] تحليل ظروف السوق وتوليد فلاتر متكيفة...")        with force_momentum_lock:        is_forced = force_momentum_strategy        if is_forced:        logger.warning("⚠️ [OVERRIDE] استراتيجية الزخم مفروضة يدوياً")        base_profile = {"adx": 25.0, "rel_vol": 0.4, "rsi_range": (52, 88), "roc": 0.05, "slope": 0.01, "min_rrr": 1.4, "min_volatility_pct": 0.35, "min_btc_correlation": 0.4, "min_bid_ask_ratio": 1.15}        description = "استراتيجية الزخم مفروضة يدوياً"    else:        enhanced_profile = enhanced_filter_system.generate_filters()        description = enhanced_profile['description']        base_profile = enhanced_profile['filters']    with dynamic_filter_lock:        dynamic_filter_profile_cache = {            "name": description,            "description": description,            "strategy": "MOMENTUM",            "filters": base_profile,            "last_updated": datetime.now(timezone.utc).isoformat(),        }        last_dynamic_filter_analysis_time = time.time()        logger.info(f"✅ [Enhanced Filter] تم توليد فلاتر متكيفة جديدة: {description}")# ---------------------- واجهة Flask ----------------------app = Flask(__name__)CORS(app)def get_dashboard_html():    # هذا هو قالب HTML الكامل مع JavaScript المدمج    return """<!DOCTYPE html><html lang="ar" dir="rtl"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>لوحة تحكم التداول V28</title>    <script src="https://cdn.tailwindcss.com"></script>    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700;800&display=swap" rel="stylesheet">    <style>        :root {            --bg-main: #0D1117; --bg-card: #161B22; --border-color: #30363D;            --text-primary: #E6EDF3; --text-secondary: #848D97;            --accent-blue: #58A6FF; --accent-green: #3FB950; --accent-red: #F85149; --accent-yellow: #D29922;        }        body { font-family: 'Tajawal', sans-serif; background-color: var(--bg-main); color: var(--text-primary); }        .card { background-color: var(--bg-card); border: 1px solid var(--border-color); border-radius: 0.5rem; transition: all 0.3s ease; }        .card:hover { border-color: var(--accent-blue); }        .trend-light { width: 1rem; height: 1rem; border-radius: 9999px; border: 2px solid rgba(255, 255, 255, 0.1); transition: background-color 0.5s ease, box-shadow 0.5s ease; }        .light-off { background-color: #30363D; }        .light-on-green { background-color: var(--accent-green); box-shadow: 0 0 10px 2px var(--accent-green); }        .light-on-red { background-color: var(--accent-red); box-shadow: 0 0 10px 2px var(--accent-red); }        .light-on-yellow { background-color: var(--accent-yellow); box-shadow: 0 0 10px 2px var(--accent-yellow); }        .tab-btn { border-bottom: 2px solid transparent; }        .tab-btn.active { border-bottom-color: var(--accent-blue); }        .toggle-bg { transition: background-color .2s ease-in-out; }        input:checked + .toggle-bg { background-color: var(--accent-green); }    </style></head><body class="p-4 md:p-6">    <div class="container mx-auto max-w-screen-2xl">        <header class="mb-6 flex flex-wrap justify-between items-center gap-4">            <h1 class="text-2xl md:text-3xl font-extrabold text-white">                <span class="text-accent-blue">لوحة تحكم التداول</span>                <span class="text-text-secondary font-medium">V28</span>            </h1>            <div id="trend-lights-container" class="flex items-center gap-x-6 bg-black/20 px-4 py-2 rounded-lg border border-border-color"></div>        </header>                <section class="mb-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-5">            <div class="card p-4">                <h3 class="font-bold mb-3 text-lg text-text-secondary">حالة السوق (BTC)</h3>                <div id="overall-regime" class="text-2xl font-bold text-center">...</div>            </div>            <div class="card p-4">                <h3 class="font-bold mb-3 text-lg text-text-secondary">ملف الفلاتر</h3>                <div id="filter-profile-name" class="text-xl font-bold text-center">...</div>            </div>            <div class="card p-4">                <h3 class="font-bold mb-3 text-lg text-text-secondary">البورصات النشطة</h3>                <div id="active-sessions-list" class="flex flex-wrap gap-2 items-center justify-center pt-2">...</div>            </div>            <div class="card p-4 flex flex-col justify-center items-center">                <h3 class="font-bold text-lg text-text-secondary mb-2">التداول الحقيقي</h3>                <div class="flex items-center space-x-3 space-x-reverse">                    <span id="trading-status-text" class="font-bold text-lg text-accent-red">غير مُفعَّل</span>                    <label class="flex items-center cursor-pointer">                        <div class="relative"><input type="checkbox" id="trading-toggle" class="sr-only" onchange="toggleTrading()"><div class="toggle-bg block bg-gray-600 w-12 h-7 rounded-full"></div></div>                    </label>                </div>                <div class="mt-2 text-xs text-text-secondary">رصيد USDT: <span id="usdt-balance" class="font-mono">...</span></div>            </div>            <div class="card p-4 flex flex-col justify-center items-center bg-blue-900/20 border-accent-blue">                <h3 class="font-bold text-lg text-text-secondary mb-2">التحكم بالاستراتيجية</h3>                <div class="flex items-center space-x-3 space-x-reverse">                    <span id="force-momentum-text" class="font-bold text-lg text-text-secondary">تلقائي</span>                    <label class="flex items-center cursor-pointer">                        <div class="relative"><input type="checkbox" id="force-momentum-toggle" class="sr-only" onchange="toggleMomentumStrategy()"><div class="toggle-bg block bg-gray-600 w-12 h-7 rounded-full"></div></div>                    </label>                </div>            </div>        </section>        <div class="mb-4 border-b border-border-color">            <nav class="flex space-x-6 space-x-reverse -mb-px">                <button onclick="showTab('signals', this)" class="tab-btn active text-white py-3 px-1 font-semibold">الصفقات</button>                <button onclick="showTab('stats', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">الإحصائيات</button>                <button onclick="showTab('notifications', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">الإشعارات</button>                <button onclick="showTab('rejections', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">الصفقات المرفوضة</button>                <button onclick="showTab('filters', this)" class="tab-btn text-text-secondary hover:text-white py-3 px-1">الفلاتر الحالية</button>            </nav>        </div>        <main>            <div id="signals-tab" class="tab-content">                <div class="overflow-x-auto card p-0"><table class="min-w-full text-sm text-right"><thead class="border-b border-border-color bg-black/20"><tr><th class="p-4 font-semibold">العملة</th><th class="p-4 font-semibold">الحالة</th><th class="p-4 font-semibold">الربح/الخسارة</th><th class="p-4 font-semibold w-[25%]">التقدم</th><th class="p-4 font-semibold">الدخول/الحالي</th></tr></thead><tbody id="signals-table"></tbody></table></div>            </div>            <div id="stats-tab" class="tab-content hidden"><div id="stats-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4"></div></div>            <div id="notifications-tab" class="tab-content hidden"><div id="notifications-list" class="card p-4 max-h-[60vh] overflow-y-auto space-y-2"></div></div>            <div id="rejections-tab" class="tab-content hidden"><div id="rejections-list" class="card p-4 max-h-[60vh] overflow-y-auto space-y-2"></div></div>            <div id="filters-tab" class="tab-content hidden"><div id="filters-display" class="card p-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div></div>        </main>    </div><script>// --- كود جافاسكريبت للوحة التحكم ---function showTab(tabId, element) {    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));    document.getElementById(tabId + '-tab').classList.remove('hidden');    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active', 'text-white'));    element.classList.add('active', 'text-white');}async function fetchData(url) {    try {        const response = await fetch(url);        if (!response.ok) {            console.error(`HTTP error! status: ${response.status}`);            return null;        }        return await response.json();    } catch (error) {        console.error('Fetch error:', error);        return null;    }}function updateMarketStatus() {    fetchData('/api/market_status').then(data => {        if (!data) return;                // تحديث حالة السوق        const regime = data.market_state?.overall_regime || 'UNCERTAIN';        const regimeText = regime.replace(/_/g, ' ');        document.getElementById('overall-regime').textContent = regimeText;                // تحديث أضواء الاتجاه        const lightsContainer = document.getElementById('trend-lights-container');        lightsContainer.innerHTML = '';        const trendDetails = data.market_state?.trend_details_by_tf || {};        ['15m', '1h', '4h'].forEach(tf => {            const trend = trendDetails[tf]?.trend || 'Uncertain';            let colorClass = 'light-off';            if (trend.includes('Uptrend')) colorClass = 'light-on-green';            else if (trend.includes('Downtrend')) colorClass = 'light-on-red';            else if (trend.includes('Ranging')) colorClass = 'light-on-yellow';                        lightsContainer.innerHTML += `                <div class="flex items-center gap-2" title="اتجاه ${tf}">                    <div class="trend-light ${colorClass}"></div>                    <span class="text-sm font-bold text-text-secondary">${tf}</span>                </div>`;        });        // تحديث ملف الفلاتر        document.getElementById('filter-profile-name').textContent = data.filter_profile?.name || 'غير متاح';        // تحديث الجلسات النشطة        const sessionsList = document.getElementById('active-sessions-list');        if (data.active_sessions && data.active_sessions.length > 0) {            sessionsList.innerHTML = data.active_sessions.map(s => `<span class="bg-accent-blue/20 text-accent-blue text-xs font-bold px-2 py-1 rounded">${s}</span>`).join('');        } else {            sessionsList.innerHTML = `<span class="bg-gray-700 text-text-secondary text-xs font-bold px-2 py-1 rounded">لا توجد</span>`;        }        // تحديث حالة التداول        const tradingToggle = document.getElementById('trading-toggle');        const tradingStatusText = document.getElementById('trading-status-text');        tradingToggle.checked = data.is_trading_enabled;        tradingStatusText.textContent = data.is_trading_enabled ? 'مُفعَّل' : 'غير مُفعَّل';        tradingStatusText.className = data.is_trading_enabled ? 'font-bold text-lg text-accent-green' : 'font-bold text-lg text-accent-red';        // تحديث الرصيد        document.getElementById('usdt-balance').textContent = data.usdt_balance ? parseFloat(data.usdt_balance).toFixed(2) : 'N/A';                // تحديث حالة فرض الاستراتيجية        const momentumToggle = document.getElementById('force-momentum-toggle');        const momentumText = document.getElementById('force-momentum-text');        momentumToggle.checked = data.force_momentum_enabled;        momentumText.textContent = data.force_momentum_enabled ? 'مفروض' : 'تلقائي';    });}function updateSignals() {    fetchData('/api/signals').then(data => {        if (!data) return;        const tableBody = document.getElementById('signals-table');        tableBody.innerHTML = '';        const openSignals = data.filter(s => ['open', 'updated'].includes(s.status));                openSignals.forEach(signal => {            const profitPct = parseFloat(signal.profit_percentage || 0);            const profitClass = profitPct > 0 ? 'text-accent-green' : (profitPct < 0 ? 'text-accent-red' : 'text-text-secondary');                        const entry = parseFloat(signal.entry_price);            const sl = parseFloat(signal.stop_loss);            const tp = parseFloat(signal.target_price);            const currentPrice = parseFloat(signal.current_price || entry);                        const progress = Math.max(0, Math.min(100, (currentPrice - sl) / (tp - sl) * 100));            tableBody.innerHTML += `                <tr class="border-b border-border-color hover:bg-white/5">                    <td class="p-4 font-bold">${signal.symbol}</td>                    <td class="p-4"><span class="px-2 py-1 text-xs font-semibold rounded-full ${signal.is_real_trade ? 'bg-blue-500/20 text-blue-400' : 'bg-yellow-500/20 text-yellow-400'}">${signal.is_real_trade ? 'حقيقي' : 'تجريبي'}</span></td>                    <td class="p-4 font-mono ${profitClass}">${profitPct.toFixed(2)}%</td>                    <td class="p-4">                        <div class="w-full bg-gray-700 rounded-full h-2.5">                            <div class="bg-accent-blue h-2.5 rounded-full" style="width: ${progress}%"></div>                        </div>                    </td>                    <td class="p-4 font-mono">${currentPrice.toFixed(4)} / ${entry.toFixed(4)}</td>                </tr>`;        });    });}function updateStats() {    fetchData('/api/stats').then(data => {        if (!data) return;        const container = document.getElementById('stats-container');        container.innerHTML = `            <div class="card p-4 text-center"><h4 class="text-text-secondary">صافي الربح (USDT)</h4><div class="text-2xl font-bold ${data.net_profit_usdt >= 0 ? 'text-accent-green' : 'text-accent-red'}">${parseFloat(data.net_profit_usdt).toFixed(2)}</div></div>            <div class="card p-4 text-center"><h4 class="text-text-secondary">معدل الربح</h4><div class="text-2xl font-bold">${parseFloat(data.win_rate).toFixed(2)}%</div></div>            <div class="card p-4 text-center"><h4 class="text-text-secondary">عامل الربح</h4><div class="text-2xl font-bold">${data.profit_factor === 'Infinity' ? '∞' : parseFloat(data.profit_factor).toFixed(2)}</div></div>            <div class="card p-4 text-center"><h4 class="text-text-secondary">إجمالي الصفقات المغلقة</h4><div class="text-2xl font-bold">${data.total_closed_trades}</div></div>        `;    });}function updateNotifications() {    fetchData('/api/notifications').then(data => {        if (!data) return;        const list = document.getElementById('notifications-list');        list.innerHTML = data.map(n => {            let color = 'text-text-secondary';            if (n.type.includes('ERROR') || n.type.includes('FAIL')) color = 'text-accent-red';            else if (n.type.includes('REAL_TRADE')) color = 'text-accent-blue';            else if (n.type.includes('SUCCESS')) color = 'text-accent-green';            return `<div class="p-2 border-b border-border-color"><span class="font-mono text-xs ${color}">${new Date(n.timestamp).toLocaleString('ar-EG')}</span>: ${n.message}</div>`;        }).join('');    });}function updateRejections() {    fetchData('/api/rejection_logs').then(data => {        if (!data) return;        const list = document.getElementById('rejections-list');        list.innerHTML = data.map(r => `            <div class="p-2 border-b border-border-color">                <span class="font-mono text-xs text-text-secondary">${new Date(r.timestamp).toLocaleString('ar-EG')}</span>:                 <strong class="text-accent-yellow">${r.symbol}</strong> - ${r.reason}                <span class="text-xs text-gray-500">${JSON.stringify(r.details)}</span>            </div>`).join('');    });}function updateFilters() {     fetchData('/api/market_status').then(data => {        if (!data || !data.filter_profile || !data.filter_profile.filters) return;        const container = document.getElementById('filters-display');        const filters = data.filter_profile.filters;        container.innerHTML = Object.entries(filters).map(([key, value]) => `            <div class="card p-3 bg-black/20">                <div class="text-sm text-text-secondary">${key}</div>                <div class="font-bold text-lg text-accent-blue">${Array.isArray(value) ? `(${value.join(', ')})` : value}</div>            </div>        `).join('');    });}function toggleTrading() {    fetch('/api/trading/toggle', { method: 'POST' }).then(() => updateMarketStatus());}function toggleMomentumStrategy() {    fetch('/api/strategy/force_momentum/toggle', { method: 'POST' }).then(() => updateMarketStatus());}// --- بدء التحديثات الدورية ---document.addEventListener('DOMContentLoaded', () => {    updateMarketStatus();    updateSignals();    updateStats();    updateNotifications();    updateRejections();    updateFilters();    setInterval(updateMarketStatus, 5000); // كل 5 ثوان    setInterval(updateSignals, 10000); // كل 10 ثوان    setInterval(updateStats, 60000); // كل دقيقة    setInterval(updateNotifications, 15000);    setInterval(updateRejections, 15000);    setInterval(updateFilters, 60000);});</script></body></html>"""@app.route('/')def home():    return render_template_string(get_dashboard_html())@app.route('/api/market_status')def get_market_status():    with market_state_lock:        state_copy = dict(current_market_state)    with force_momentum_lock:        is_forced = force_momentum_strategy    with trading_status_lock:        is_enabled = is_trading_enabled    with dynamic_filter_lock:        profile_copy = dict(dynamic_filter_profile_cache)            active_sessions, _, _ = get_session_state()    usdt_balance = None    if client:        try:            usdt_balance = float(client.get_asset_balance(asset='USDT')['free'])        except Exception as e:            logger.warning(f"Could not fetch USDT balance: {e}")    return jsonify({        "market_state": state_copy,        "filter_profile": profile_copy,        "active_sessions": active_sessions,        "db_ok": check_db_connection(),        "api_ok": True if client else False,        "usdt_balance": usdt_balance,        "is_trading_enabled": is_enabled,        "force_momentum_enabled": is_forced    })@app.route('/api/stats')def get_stats():    if not check_db_connection(): return jsonify({"error": "DB connection failed"}), 500    try:        with conn.cursor() as cur:            cur.execute("SELECT status, profit_percentage, is_real_trade, quantity, entry_price FROM signals WHERE status = 'closed';")            closed_trades = cur.fetchall()                if not closed_trades:            return jsonify({                "net_profit_usdt": 0, "win_rate": 0, "profit_factor": 0,                "total_closed_trades": 0, "average_win_pct": 0, "average_loss_pct": 0            })        total_net_profit_usdt = 0.0        for t in closed_trades:            profit_pct = float(t['profit_percentage']) - (2 * TRADING_FEE_PERCENT)            trade_size = STATS_TRADE_SIZE_USDT            if t.get('is_real_trade') and t.get('quantity') and t.get('entry_price'):                trade_size = float(t['quantity']) * float(t['entry_price'])            total_net_profit_usdt += (profit_pct / 100) * trade_size                wins_list = [float(s['profit_percentage']) for s in closed_trades if float(s['profit_percentage']) > 0]        losses_list = [float(s['profit_percentage']) for s in closed_trades if float(s['profit_percentage']) < 0]        win_rate = (len(wins_list) / len(closed_trades) * 100) if closed_trades else 0.0        avg_win = sum(wins_list) / len(wins_list) if wins_list else 0.0        avg_loss = sum(losses_list) / len(losses_list) if losses_list else 0.0        profit_factor_val = sum(wins_list) / abs(sum(losses_list)) if abs(sum(losses_list)) > 0 else "Infinity"        return jsonify({            "net_profit_usdt": total_net_profit_usdt,            "win_rate": win_rate,            "profit_factor": profit_factor_val,            "total_closed_trades": len(closed_trades),            "average_win_pct": avg_win,            "average_loss_pct": avg_loss        })    except Exception as e:        logger.error(f"❌ [API Stats] Error: {e}", exc_info=True)        if conn: conn.rollback()        return jsonify({"error": "Internal error in stats"}), 500@app.route('/api/signals')def get_signals():    if not all([check_db_connection(), redis_client, client]):        return jsonify({"error": "Service connection failed"}), 500    try:        current_prices = redis_client.hgetall(REDIS_PRICES_HASH_NAME)        with conn.cursor() as cur:            cur.execute("SELECT * FROM signals ORDER BY CASE WHEN status IN ('open', 'updated') THEN 0 ELSE 1 END, id DESC;")            all_signals = [dict(s) for s in cur.fetchall()]                for signal in all_signals:            if signal['status'] in ['open', 'updated']:                current_price = current_prices.get(signal['symbol'])                if current_price:                    signal['current_price'] = current_price                    entry = float(signal['entry_price'])                    signal['profit_percentage'] = ((float(current_price) - entry) / entry) * 100        return jsonify(all_signals)    except Exception as e:        logger.error(f"❌ [API Signals] Error: {e}", exc_info=True)        if conn: conn.rollback()        return jsonify({"error": str(e)}), 500@app.route('/api/notifications')def get_notifications():    with notifications_lock:        return jsonify(list(notifications_cache))@app.route('/api/rejection_logs')def get_rejection_logs():    with rejection_logs_lock:        return jsonify(list(rejection_logs_cache))@app.route('/api/trading/toggle', methods=['POST'])def toggle_trading_status():    global is_trading_enabled    with trading_status_lock:        is_trading_enabled = not is_trading_enabled        status_msg = "ENABLED" if is_trading_enabled else "DISABLED"        log_and_notify('warning', f"🚨 Real trading status changed to: {status_msg}", "TRADING_STATUS_CHANGE")        return jsonify({"message": f"Trading status set to {status_msg}", "is_enabled": is_trading_enabled})@app.route('/api/strategy/force_momentum/toggle', methods=['POST'])def toggle_force_momentum():    global force_momentum_strategy    with force_momentum_lock:        force_momentum_strategy = not force_momentum_strategy        status_msg = "FORCED MOMENTUM" if force_momentum_strategy else "AUTOMATIC"        log_and_notify('warning', f"⚙️ Strategy mode changed to: {status_msg}", "STRATEGY_MODE_CHANGE")        # إعادة تحليل السوق فوراً بعد التغيير        Thread(target=analyze_market_and_create_dynamic_profile_enhanced).start()        return jsonify({"message": f"Strategy mode set to {status_msg}", "is_forced": force_momentum_strategy})# ---------------------- حلقات النظام ----------------------def main_loop_enhanced():    """الحلقة الرئيسية للبحث عن إشارات التداول."""    logger.info("[Enhanced Main Loop] انتظار اكتمال التهيئة...")    time.sleep(15)    if not validated_symbols_to_scan:        log_and_notify("critical", "لا توجد عملات صالحة للمسح. لن يبدأ البوت.", "SYSTEM")        return    log_and_notify("info", f"✅ بدء حلقة المسح المحسنة لـ {len(validated_symbols_to_scan)} عملة.", "SYSTEM")    while True:        try:            logger.info("🔄 بدء دورة مسح محسنة جديدة...")            ml_models_cache.clear(); gc.collect()            determine_market_state_enhanced()            analyze_market_and_create_dynamic_profile_enhanced()                        with dynamic_filter_lock:                filter_profile = dynamic_filter_profile_cache                        if not filter_profile:                logger.warning("🛑 لم يتم تحميل ملف الفلاتر بعد. تخطي الدورة.")                time.sleep(60)                continue            btc_data = get_btc_data_for_bot()                        symbols_with_models = [s for s in validated_symbols_to_scan if os.path.exists(os.path.join(os.path.dirname(os.path.abspath(__file__)), MODEL_FOLDER, f"{BASE_ML_MODEL_NAME}_{s}.pkl"))]                        if not symbols_with_models:                logger.warning("⚠️ لا توجد عملات لها نماذج تعلم آلي. تخطي دورة المسح.")                time.sleep(300)                continue                            symbols_to_process = random.sample(symbols_with_models, len(symbols_with_models))                        processed_count = 0            for symbol in symbols_to_process:                try:                    with signal_cache_lock:                        if symbol in open_signals_cache or len(open_signals_cache) >= MAX_OPEN_TRADES:                            continue                                        df_15m = fetch_historical_data(symbol, SIGNAL_GENERATION_TIMEFRAME, SIGNAL_GENERATION_LOOKBACK_DAYS)                    if df_15m is None or df_15m.empty: continue                                        strategy = EnhancedTradingStrategy(symbol)                    if not all([strategy.ml_model, strategy.scaler, strategy.feature_names]): continue                                        df_4h = fetch_historical_data(symbol, '4h', SIGNAL_GENERATION_LOOKBACK_DAYS)                    if df_4h is None or df_4h.empty: continue                                        df_features = strategy.get_features(df_15m, df_4h, btc_data)                    if df_features is None or df_features.empty: continue                                        ml_signal = strategy.generate_buy_signal(df_features)                                        if not ml_signal or ml_signal['confidence'] < BUY_CONFIDENCE_THRESHOLD:                        continue                                        try:                        entry_price = float(client.get_symbol_ticker(symbol=symbol)['price'])                    except Exception as e:                        logger.error(f"❌ [{symbol}] لم يتمكن من جلب سعر الدخول: {e}. تخطي.")                        continue                    last_features = df_features.iloc[-1]                    last_atr = last_features.get('atr', 0)                    tp_sl_data = calculate_tp_sl(symbol, entry_price, last_atr)                                        if not tp_sl_data or not passes_filters(symbol, last_features, filter_profile, entry_price, tp_sl_data, df_15m):                        continue                    order_book_analysis = analyze_order_book(symbol, entry_price)                    if not order_book_analysis or not passes_order_book_check(symbol, order_book_analysis, filter_profile):                        continue                                        new_signal = {                        'symbol': symbol, 'strategy_name': "Momentum_ML_Enhanced",                        'signal_details': {                            'ML_Confidence': f"{ml_signal['confidence']:.2%}",                            'Filter_Profile': f"{filter_profile['name']}",                            'Bid_Ask_Ratio': order_book_analysis.get('bid_ask_ratio', 0),                        },                        'entry_price': entry_price, **tp_sl_data                    }                                        with trading_status_lock: is_enabled = is_trading_enabled                    if is_enabled:                        quantity = calculate_position_size(symbol, entry_price, new_signal['stop_loss'])                        if quantity and quantity > 0:                            order_result = place_order(symbol, Client.SIDE_BUY, quantity)                            if order_result:                                new_signal.update({'is_real_trade': True, 'quantity': float(quantity), 'order_id': order_result['orderId']})                            else: continue                        else: continue                    else:                        new_signal['is_real_trade'] = False                    saved_signal = insert_signal_into_db(new_signal)                    if saved_signal:                        with signal_cache_lock:                            open_signals_cache[saved_signal['symbol']] = saved_signal                        log_and_notify('info', f"SIGNAL: New buy signal for {symbol} at {entry_price}", "NEW_SIGNAL")                except Exception as e:                    logger.error(f"❌ [Enhanced Processing Error] للعملة {symbol}: {e}", exc_info=True)                finally:                    processed_count += 1                    if processed_count % SYMBOL_PROCESSING_BATCH_SIZE == 0:                        logger.info("📦 تم معالجة دفعة. تنظيف الذاكرة...")                        ml_models_cache.clear(); gc.collect()                        time.sleep(2)                    time.sleep(0.75)                        logger.info("✅ [Enhanced End of Cycle] انتهت دورة المسح الكاملة.")            gc.collect()            logger.info(f"⏳ [Enhanced End of Cycle] الانتظار لمدة 60 ثانية...")            time.sleep(60)        except (KeyboardInterrupt, SystemExit):            log_and_notify("info", "إيقاف البوت بناءً على طلب المستخدم.", "SYSTEM")            break        except Exception as main_err:            log_and_notify("error", f"خطأ حرج في الحلقة الرئيسية المحسنة: {main_err}", "SYSTEM")            time.sleep(120)def price_update_loop():    """حلقة لتحديث الأسعار الحالية في Redis."""    if not redis_client:        logger.error("Redis client not initialized. Price update loop cannot start.")        return        while True:        try:            if validated_symbols_to_scan:                tickers = client.get_symbol_ticker()                prices_to_set = {t['symbol']: t['price'] for t in tickers if t['symbol'] in validated_symbols_to_scan}                if prices_to_set:                    redis_client.hset(REDIS_PRICES_HASH_NAME, mapping=prices_to_set)            time.sleep(2) # تحديث كل ثانيتين        except Exception as e:            logger.error(f"Error in price update loop: {e}")            time.sleep(10)def initialize_bot_services():    """تهيئة جميع خدمات البوت الخلفية."""    global client, validated_symbols_to_scan    logger.info("🤖 [Bot Services] بدء التهيئة الخلفية المحسنة...")    try:        client = Client(API_KEY, API_SECRET)        init_db()        init_redis()        get_exchange_info_map()        load_open_signals_to_cache()        load_notifications_to_cache()                validated_symbols_to_scan = get_validated_symbols()        if not validated_symbols_to_scan:            logger.critical("❌ لا توجد عملات صالحة للمسح. لن يبدأ البوت.")            return                # بدء الحلقات في threads منفصلة        Thread(target=main_loop_enhanced, daemon=True).start()        Thread(target=price_update_loop, daemon=True).start()                logger.info("✅ [Bot Services] تم بدء جميع الخدمات الخلفية المحسنة بنجاح.")    except Exception as e:        log_and_notify("critical", f"حدث خطأ حرج أثناء التهيئة: {e}", "SYSTEM")        exit(1)# ---------------------- نقطة الانطلاق ----------------------if __name__ == "__main__":    logger.info("🚀 إطلاق بوت التداول ولوحة التحكم المحسنة (V28 - نسخة كاملة) 🚀")    initialization_thread = Thread(target=initialize_bot_services, daemon=True)    initialization_thread.start()        port = int(os.environ.get('PORT', 10000))    host = "0.0.0.0"    logger.info(f"✅ التحضير لبدء لوحة التحكم على {host}:{port}")    try:        from waitress import serve        serve(app, host=host, port=port, threads=8)    except ImportError:        logger.warning("⚠️ 'waitress' غير موجود. سيتم استخدام خادم التطوير الخاص بـ Flask.")        app.run(host=host, port=port)    logger.info("👋 [Shutdown] تم إيقاف تشغيل التطبيق.")